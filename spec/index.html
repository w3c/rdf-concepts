<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>RDF 1.2 Concepts and Abstract Syntax</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  <script src="./common/local-biblio.js" class="remove"></script>
  <script src="./common/fixup.js" class="remove"></script>
  <script class='remove'>
    var respecConfig = {
      localBiblio:          localBibliography,
      specStatus:           "ED",
      edDraftURI:           "https://w3c.github.io/rdf-concepts/spec/",
      shortName:            "rdf12-concepts",
      copyrightStart:       "2004",

      previousPublishDate:  "2014-02-25",
      previousMaturity:     "REC",
      prevRecShortname:     "rdf11-concepts",

      editors:  [
        { name: "Olaf Hartig", w3cid: "112469"},
        { name: "Pierre-Antoine Champin", w3cid: "129656"},
        { name: "Gregg Kellogg", w3cid: "44770" },
        { name: "Andy Seaborne", w3cid: "29909" }
      ],

      formerEditors: [
        { name: "Richard Cyganiak" },
        { name: "David Wood", note: "Chair" },
        { name: "Markus Lanthaler" },
        { name: "Graham Klyne" },
        { name: "Jeremy J. Carroll" },
        { name: "Brian McBride" }
      ],

      xref: ["I18N-GLOSSARY", "INFRA"],
      github: "https://github.com/w3c/rdf-concepts/",
      group:           "rdf-star",
      doJsonLd:     true,
      wgPublicList: "public-rdf-star-wg",
      maxTocLevel: 2,
    };
  </script>
  <style>
    figure { text-align: center; }
    table.simple td, table th { border: 1px solid #ddd; padding: 0.2em 0.5em; }
    ol ol { list-style-type: lower-latin; }
    .grammar td { font-family: monospace;}
    .grammar-literal { color: gray;}
    code {color: #ff4500;}  /* Old W3C Style */
    div.abnf {margin-left: 1em;}

  .algorithm ol {
    counter-reset: numsection;
    list-style-type: none;
  }
  .algorithm ol>li {
    margin: 0.5em 0;
  }
  .algorithm ol>li:before {
    font-weight: bold;
    counter-increment: numsection;
    content: counters(numsection, ".") ") ";
  }
  </style>
</head>

<body>
<section id="abstract">
  <p>The Resource Description Framework (RDF) is a framework for
    representing information in the Web.
    This document defines an abstract syntax (a data model)
    which serves to link all RDF-based languages and specifications.
    The abstract syntax has two key data structures:</p>
  <ul>
    <li>RDF graphs are sets of subject-predicate-object triples,
      where the elements may be IRIs, blank nodes, or datatyped literals.
      They are used to express descriptions of resources.</li>
    <li>RDF datasets are used to organize collections of RDF graphs,
      are comprised of a default graph and zero or more named graphs.</li>
  </ul>

  <p>RDF 1.2 introduces the ability to use an <a>RDF triple</a>
    as a <a>triple term</a>, in the <a>object</a> position of another <a>triple</a>.
    RDF 1.2 also introduces <a>directional language-tagged strings</a>,
    which contain a <a>base direction</a> element that allows the
    initial text direction to be specified for presentation by a user agent.</p>

  <p>RDF 1.2 Concepts introduces key concepts and terminology for RDF 1.2, discusses
    datatyping, and the handling of <a>fragment identifiers</a> in IRIs within
    RDF graphs.</p>
</section>

<section id="sotd" class="updateable-rec">
  <p>This document is part of the RDF 1.2 document suite.
    It is the central RDF 1.2 specification and defines the core RDF concepts.
    Test suites and implementation reports of a number of RDF 1.2
    specifications that build on this document are available through the  
    [[[RDF11-TESTCASES]]] document [[RDF11-TESTCASES]].</p>

  <p>RDF 1.2 Concepts is an update to [[RDF11-CONCEPTS]],
    which was itself, an update to [[RDF-CONCEPTS-20040210]].</p>
  <p class="ednote">Determine how to reference 1.2 test cases.</p>

  <section id="related" data-include="./common/related.html"></section>
</section>

<section id="section-Introduction" class="informative">
  <h2>Introduction</h2>

  <p>The <em>Resource Description Framework</em> (RDF) is a framework
  for representing information in the Web.</p>

  <p>This document defines an abstract syntax (a data model)
  which serves to link all RDF-based languages and specifications,
  including the following:</p>

  <ul>
    <li>the formal model-theoretic semantics for RDF [[RDF12-SEMANTICS]]</li>

    <li>serialization syntaxes for storing and exchanging RDF such as [[[RDF12-TURTLE]]] [[RDF12-TURTLE]]
      and [[[JSON-LD11]]] [[JSON-LD11]]</li>

    <li>the [[[SPARQL12-QUERY]]] [[SPARQL12-QUERY]]</li>

    <li>the [[[RDF12-SCHEMA]]] [[RDF12-SCHEMA]]</li>
  </ul>

  <section id="data-model">
    <h3>Graph-based Data Model</h3>

    <p>The core structure of the abstract syntax is a set of
      <a data-lt="RDF triple">triples</a>, each consisting of a <a>subject</a>,
      a <a>predicate</a> and an <a>object</a>. A set of such triples is called
      an <a>RDF graph</a>. An RDF graph can be visualized as a node and
      directed-arc diagram, in which each triple is represented as a
      node-arc-node link.</p>

    <figure id="fig-rdf-graph">
      <a href="rdf-graph.svg"><img src="rdf-graph.svg" alt="An RDF graph with two nodes (Subject and Object) and a triple connecting them (Predicate)" /></a>
      <figcaption>An RDF graph with two nodes (Subject and Object) and a triple connecting them (Predicate)</figcaption>
    </figure>

    <p>There can be four kinds of <a>nodes</a> in an
      <a>RDF graph</a>: <a>IRIs</a>, <a>literals</a>,
      <a>blank nodes</a>, and <a>triple terms</a>.</p>

    <p class="issue" data-number="129">There is a mixture of "Abstract Syntax" and "Data Model". We should have a consistent way to say "Abstract Syntax" vs "Data Model". One way is to use "Abstract Syntax" as the basis of semantics and usually say "Data Model" in Concepts otherwise.</p>
  </section>

  <section id="resources-and-statements">
    <h3>Resources and Statements</h3>

    <p>Any <a>IRI</a> or <a>literal</a> <dfn data-lt="denote" data-local-lt="denoted">denotes</dfn>
    something in the world (the "universe of discourse").
    These things are called
    <span id="dfn-resources"><!-- obsolete term --></span>
    <dfn data-lt="resource">resources</dfn>. Anything can be a resource,
    including physical things, documents, abstract concepts, numbers
    and strings; the term is synonymous with "entity" as it is used in
    [[[RDF12-SEMANTICS]]] [[RDF12-SEMANTICS]].
    The resource denoted by an IRI is called its <a>referent</a>, and the
    resource denoted by a literal is called its
    <a>literal value</a>. Literals have
    <a>datatypes</a> that define the range of possible
    values, such as strings, numbers, and dates. Special kinds of literals &mdash;
    <a>language-tagged strings</a> and <a>directional language-tagged strings</a> &mdash;
    respectively denote plain-text strings in a natural language, and plain-text
    strings in a natural language including an initial text direction.</p>

    <p>Asserting an <a>RDF triple</a> says that <em>some relationship,
    indicated by the <a>predicate</a>, holds between the
    <a>resources</a> <a>denoted</a> by
    the <a>subject</a> and <a>object</a></em>. This statement corresponding
    to an RDF triple is known as an <dfn data-local-lt="statement">RDF statement</dfn>.
    The predicate itself is an <a>IRI</a> and denotes a <dfn class="export">property</dfn>,
    that is, a <a>resource</a> that can be thought of as a binary relation.
    (Relations that involve more than two entities can only be
    <a data-cite="SWBP-N-ARYRELATIONS#">indirectly
    expressed in RDF</a> [[SWBP-N-ARYRELATIONS]].)</p>

    <p>Unlike <a>IRIs</a> and <a>literals</a>,
      <a>blank nodes</a> do not identify specific
      <a>resources</a>. <a>Statements</a>
      involving blank nodes say that something with the given relationships
      exists, without explicitly naming it.</p>
  </section>

  <section id="referents">
    <h3>The Referent of an IRI</h3>

    <p>The <a>resource</a> <a>denoted</a> by an <a>IRI</a>
      is also called its <dfn>referent</dfn>. For some IRIs with particular
      meanings, such as those identifying XSD datatypes, the referent is
      fixed by this specification. For all other IRIs, what exactly is
      <a>denoted</a> by any given IRI is not defined by this specification. Other
      specifications may fix IRI referents, or apply other constraints on
      what may be the referent of any IRI.</p>

    <p>Guidelines for determining the <a>referent</a> of an <a>IRI</a> are
      provided in other documents, like
      [[[WEBARCH]]] [[WEBARCH]]
      and [[[COOLURIS]]] [[COOLURIS]].
      A very brief, informal, and partial account follows:</p>

    <ul>
      <li>By design, IRIs have global scope. Thus, two different appearances of an IRI
        <a>denote</a> the same <a>resource</a>. Violating this principle constitutes
        an <a data-cite="WEBARCH#URI-collision">IRI collision</a> [[WEBARCH]].</li>

      <li>By social convention, the
        <a data-cite="WEBARCH#uri-ownership">IRI owner</a>
        [[WEBARCH]] gets to say what the intended (or usual)
        referent of an <a>IRI</a> is. Applications and users need not
        abide by this intended denotation, but there may be a loss of
        interoperability with other applications and users if they do
        not do so.</li>

      <li>The IRI owner can establish the intended <a>referent</a>
        by means of a specification or other document that explains
        what is denoted. For example, the
        [[[VOCAB-ORG]]] [[VOCAB-ORG]]
        specifies the intended referents of various IRIs that start with
        <code>http://www.w3.org/ns/org#</code>.</li>

      <li>A good way of communicating the intended referent
        is to set up the IRI so that it
        <a data-cite="WEBARCH#uri-dereference">dereferences</a> [[WEBARCH]]
        to such a document.</li>

      <li>Such a document can, in fact, be an <a>RDF document</a>
        that describes the denoted resource by means of
        <a>RDF statements</a>.</li>
    </ul>

    <p>Perhaps the most important characteristic of <a>IRIs</a>
      in web architecture is that they can be
      <a data-cite="WEBARCH#uri-dereference">dereferenced</a>,
      and hence serve as starting points for interactions with a remote server.
      This specification is not concerned with such interactions.
      It does not define an interaction model. It only treats IRIs as globally
      unique identifiers in a graph data model that describes resources.
      However, those interactions are critical to the concept of
      [[[LINKED-DATA]]], [[LINKED-DATA]],
      which makes use of the RDF data model and serialization formats.</p>
  </section>

  <section id="vocabularies">
    <h3>RDF Vocabularies and Namespace IRIs</h3>

    <p>An <dfn data-local-lt="vocabulary">RDF vocabulary</dfn> is a collection of <a>IRIs</a>
      intended for use in <a>RDF graphs</a>. For example,
      the IRIs documented in [[RDF12-SCHEMA]] are the RDF Schema vocabulary.
      RDF Schema can itself be used to define and document additional
      RDF vocabularies. Some such vocabularies are mentioned in the
      Primer [[RDF12-PRIMER]].</p>

    <p>The <a>IRIs</a> in an <a>RDF vocabulary</a> often begin with
      a common substring known as a <dfn>namespace IRI</dfn>.
      Some namespace IRIs are associated by convention with a short name
      known as a <dfn>namespace prefix</dfn>. Some examples:

    <table id="tab-vocab-ns" class="simple">
      <caption>Some example namespace prefixes and IRIs</caption>
      <tr>
        <th>Namespace prefix</th>
        <th>Namespace IRI</th>
        <th>RDF vocabulary</th>
      </tr>
      <tr>
        <td>rdf</td>
        <td><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></a></td>
        <td>The RDF built-in vocabulary [[RDF12-SCHEMA]]</td>
      </tr>
      <tr><td>rdfs</td>
        <td><a href="http://www.w3.org/2000/01/rdf-schema#"><code>http://www.w3.org/2000/01/rdf-schema#</code></a></td>
        <td>The RDF Schema vocabulary [[RDF12-SCHEMA]]</td>
      </tr>
      <tr><td>xsd</td>
        <td><a href="http://www.w3.org/2001/XMLSchema#"><code>http://www.w3.org/2001/XMLSchema#</code></a></td>
        <td>The <a>RDF-compatible XSD types</a></td>
      </tr>
    </table>

    <p>In some serialization formats it is common to abbreviate <a>IRIs</a>
      that start with <a>namespace IRIs</a> by using a
      <a>namespace prefix</a> in order to assist readability. For example, the IRI
      <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral</code>
      would be abbreviated as <code>rdf:XMLLiteral</code>.
      Note however that these abbreviations are <em>not</em> valid IRIs,
      and must not be used in contexts where IRIs are expected.
      Namespace IRIs and namespace prefixes are <em>not</em> a formal part of the
      RDF data model. They are merely a syntactic convenience for
      abbreviating IRIs.</p>

    <p>The term “<dfn class="lint-ignore">namespace</dfn>” on its own does not have a
      well-defined meaning in the context of RDF, but is sometimes informally
      used to mean “<a>namespace IRI</a>” or “<a>RDF vocabulary</a>”.</p>
  </section>

  <section id="section-triple-terms-reification">
    <h3>Triple Terms and Reification</h3>

    <p>A <a>triple term</a> is an [=RDF triple=] used as an [=RDF term=]
      in the [=object=] position of another triple.</p>

    <p>A <a>triple term</a> is not necessarily asserted, allowing
      statements to be made about other statements that may not be
      asserted within an <a>RDF graph</a>.
      This allows statements to be made about relationships that may be contradictory.
      For a <a>triple term</a> to be asserted,
      it must also appear in a graph as an <a>asserted triple</a>.</p>

    <p>A <a>triple term</a> can be used as the object of a <a>triple</a> with the predicate <code>rdf:reifies</code>;
      such a <a>triple</a> is then a <dfn>reifying triple</dfn>.
      The <a>subject</a> of that <a>triple</a> is called a <dfn>reifier</dfn>.
      Assertions on the <a>triple term</a> are made using the <a>reifier</a>.
      A concrete syntax may provide a special notation for specifying <a>reifying triples</a>.</p>

    <p class="note">Using the <a>reifier</a> as an indirect way of referencing a <a>triple term</a>
      allows multiple groups of assertions to be separated from each other,
      which might be necessary if the same <a>triple term</a> was derived from different sources.
      Assertions are always made using the <a>reifier</a>, which can be the <a>subject</a> or <a>object</a>
      of different triples.
      Concrete syntaxes, such as Turtle [[RDF12-TURTLE]],
      may have shortcuts for capturing a <a>triple term</a> with its <a>reifier</a>.</p>

    <p>The following diagram represents a statement and a reification of an unasserted <a>triple term</a>.</p>

    <figure id="fig-triple-term">
      <a href="triple-term.svg">
        <!-- A version of this graphic can be found at https://docs.google.com/drawings/d/1RP9Nw5GCNjduWSXZj_EZ8FaAc7p_N-WVmzJ0syvum1k -->
        <img src="triple-term.svg"
             alt="An RDF graph containing a triple that references an unasserted triple term (with grey background) via a reifier"
             style="width:70%"
             aria-describedby="fig-triple-term-alt"/>
      </a>
      <figcaption id="fig-triple-term-alt">
        An <a>RDF graph</a> containing a <a>triple</a> that references an unasserted <a>triple term</a> (with grey background) via a <a>reifier</a>.
      </figcaption>
    </figure>

    <p>A variation on the graph shown in <a href="#fig-triple-term"></a> can be described
      where the <a>triple term</a> is also <a data-lt="asserted triple">asserted</a>.</p>

    <figure id="fig-asserted-triple-term">
      <a href="asserted-triple-term.svg">
        <!-- A version of this graphic can be found at https://docs.google.com/drawings/d/1gAHQj4wk87tmeHf4-wnxdgmjq3T05_ovrJq0V-1VXKw -->
        <img src="asserted-triple-term.svg"
             alt="An RDF graph containing a triple that references an triple term, which is also asserted, via a reifier"
             style="width:70%"
             aria-describedby="fig-asserted-triple-term-alt"/>
      </a>
      <figcaption id="fig-asserted-triple-term-alt">
        An <a>RDF graph</a> containing a <a>triple</a> that references an <a>triple term</a>, which is also asserted, via a <a>reifier</a>.
      </figcaption>
    </figure>

    <p>Note that a <a>triple term</a> may also have another <a>triple term</a> as an <a>object</a>.</p>
  </section>

  <section id="change-over-time">
    <h3>RDF and Change over Time</h3>

    <p>The RDF data model is <em>atemporal</em>: <a>RDF graphs</a>
      are static snapshots of information.</p>

    <p>However, <a>RDF graphs</a> can express information
      about events and about temporal aspects of other entities,
      given appropriate <a>vocabulary</a> terms.</p>

    <p>Since <a>RDF graphs</a> are defined as mathematical
      sets, adding or removing <a>triples</a> from an
      RDF graph yields a different RDF graph.</p>

    <p>We informally use the term <dfn>RDF source</dfn> to refer to a
      persistent yet mutable source or container of
      <a>RDF graphs</a>. An RDF source is a <a>resource</a>
      that may be said to have a state that can change over time.
      A snapshot of the state can be expressed as an RDF graph.
      For example, any web document that has an RDF-bearing representation
      may be considered an RDF source. Like all resources, RDF sources may
      be named with <a>IRIs</a> and therefore described in
      other RDF graphs.</p>

    <p>Intuitively speaking, changes in the universe of discourse
      can be reflected in the following ways:</p>

    <ul>
      <li>An <a>IRI</a>, once minted, should never
        change its intended <a>referent</a>. (See
        <a data-cite="WEBARCH#URI-persistence">URI persistence</a>
        [[WEBARCH]].)</li>
      <li><a>Literals</a>, by design, are constants and
        never change their <a data-lt="literal value">value</a>.</li>
      <li>A relationship that holds between two <a>resources</a>
        at one time may not hold at another time.</li>
      <li><a>RDF sources</a> may change their state over time.
        That is, they may provide different <a>RDF graphs</a>
        at different times.</li>
      <li>Some <a>RDF sources</a> may, however, be immutable
        snapshots of another RDF source, archiving its state at some
        point in time.</li>
    </ul>
  </section>

  <section id="managing-graphs">
    <h3>Working with Multiple RDF Graphs</h3>

    <p>As RDF graphs are sets of triples, they can be
      combined easily, supporting the use of data from
      multiple sources. Nevertheless, it is sometimes desirable to work
      with multiple RDF graphs while keeping their contents separate.
      <a>RDF datasets</a> support this requirement.</p>

    <p>An <a>RDF dataset</a> is a collection of
      <a>RDF graphs</a>. All but one of these graphs have
      an associated <a>IRI</a> or blank node. They are called
      <a>named graphs</a>, and the IRI or blank node
      is called the <a>graph name</a>.
      The remaining graph does not have an associated IRI, and is called
      the <a>default graph</a> of the RDF dataset.</p>

    <p>There are many possible uses for <a>RDF datasets</a>.
      One such use is to hold snapshots of multiple
      <a>RDF sources</a>.</p>
  </section>

  <section id="entailment">
    <h3>Equivalence, Entailment and Inconsistency</h3>

    <p>An <a>RDF triple</a> encodes a <dfn class="export">proposition</dfn> — a
      simple logical expression, describing a relationship between two entities.
      An [=asserted triple=] is a claim that the corresponding proposition is true.
      An <a>RDF graph</a> is the conjunction (logical <em>AND</em>) of
      all the claims made by its [=asserted triples=].
      The precise details of this meaning of [=RDF triples=] and [=RDF graphs=] are
      the subject of [[[RDF12-SEMANTICS]]] [[RDF12-SEMANTICS]], which yields the
      following relationships between <a>RDF graphs</a>:</p>

    <dl>
      <dt><dfn>Entailment</dfn></dt>
      <dd>An <a>RDF graph</a> <em>A</em> entails another RDF graph <em>B</em>
        if every possible arrangement of the world
        that makes <em>A</em> true also makes <em>B</em> true. When <em>A</em>
        entails <em>B</em>, if the truth of <em>A</em> is presumed or demonstrated
        then the truth of <em>B</em> is established.
      </dd>

      <dt><dfn data-local-lt="equivalent">Equivalence</dfn></dt>
      <dd>Two <a>RDF graphs</a> <em>A</em> and <em>B</em>
        are equivalent if they make the same claim about the world.
        <em>A</em> is equivalent to <em>B</em> if and only if
        <em>A</em> <a data-lt="entailment">entails</a> <em>B</em> and
        <em>B</em> entails <em>A</em>.
      </dd>

      <dt><dfn data-lt="inconsistent">Inconsistency</dfn><span id="dfn-inconsistency"><!-- obsolete term --></span></dt>
      <dd>An <a>RDF graph</a> is inconsistent if it contains
        an internal contradiction. There is no possible arrangement
        of the world that would make the expression true.</dd>
    </dl>

    <p class="issue" data-number="118"></p>

    <p>An <span id="dfn-entailment-regime"><!-- obsolete term --></span><dfn data-cite="RDF12-SEMANTICS#dfn-entailment-regime">entailment regime</dfn> [[RDF12-SEMANTICS]] is a specification that
      defines precise conditions that make these relationships hold.
      RDF itself recognizes only some basic cases of entailment, <a>equivalence</a>
      and inconsistency. Other specifications, such as
      [[[RDF12-SCHEMA]]] [[RDF12-SCHEMA]]
      and <a data-cite="owl2-overview#">OWL 2</a>
      [[OWL2-OVERVIEW]], add more powerful entailment regimes,
      as do some domain-specific <a>vocabularies</a>.</p>

    <p>This specification does not constrain how implementations
      use the logical relationships defined by
      <a>entailment regimes</a>.
      Implementations may or may not detect
      <a>inconsistencies</a>, and may make all,
      some or no <a data-lt="entailment">entailed</a> information
      available to users.</p>
  </section>

  <section id="rdf-documents">
    <h3>RDF Documents and Syntaxes</h3>

    <p>An <dfn>RDF document</dfn> is a document that encodes an
      <a>RDF graph</a> or <a>RDF dataset</a> in a <dfn>concrete RDF syntax</dfn>,
      such as Turtle [[RDF12-TURTLE]], RDFa [[RDFA-CORE]], JSON-LD [[JSON-LD11]], or
      TriG [[RDF12-TRIG]]. RDF documents enable the exchange of RDF graphs and RDF
      datasets between systems.</p>

    <p>A <a>concrete RDF syntax</a> may offer
      many different ways to encode the same <a>RDF graph</a> or
      <a>RDF dataset</a>, for example through the use of
      <a>namespace prefixes</a>,
      <a>IRI references</a>, <a>blank node identifiers</a>,
      and different ordering of triples. While these aspects can have great
      effect on the convenience of working with the <a>RDF document</a>,
      they are not significant for its meaning.</p>
  </section>
</section>

<section id="conformance">
  <p>This specification, <em>RDF 1.2 Concepts and Abstract Syntax</em>,
    defines a data model and related terminology for use in
    other specifications, such as
    <a>concrete RDF syntaxes</a>,
    API specifications, and query languages.
    Implementations cannot directly conform to
    <em>RDF 1.2 Concepts and Abstract Syntax</em>,
    but can conform to such other specifications that normatively
    reference terms defined here.</p>

  <p>This specification establishes two conformance levels:</p>

  <ul>
    <li><dfn class="no-export lint-ignore" data-lt="full">Full conformance</dfn>
      supports <a data-lt="RDF graph">graphs</a> and <a data-lt="RDF dataset">datasets</a>
      with <a>triples</a> that contain <a>triple terms</a>.
      Concrete syntaxes in which such graphs and datasets can be expressed include
      [[RDF12-N-TRIPLES]], [[RDF12-N-QUADS]], [[RDF12-TURTLE]], and [[RDF12-TRIG]].</li>
    <li><dfn class="no-export lint-ignore" data-lt="classic">Classic conformance</dfn>
      only supports <a data-lt="RDF graph">graphs</a> or <a data-lt="RDF dataset">datasets</a>
      with <a>triples</a> that do not contain <a>triple terms</a>.</li>
  </ul>
  <p class="ednote">The conformance levels described above are tentative,
    and still the subject of group discussion. An alternative to conformance
    levels, "profiles", may be adopted instead, abandoned, or described in 
    another specification.</p>
  <p class="issue" data-number="70">
    Change "Classic Conformance" to "Basic Conformance" and define them as profiles.</p>

  <section id="rdf-strings">
    <h3>Strings in RDF</h3>

    <p>RDF uses Unicode [[Unicode]] as the fundamental representation for string values.
      Within this, and related specifications, the term <dfn id="dfn-rdf-string">string</dfn>,
      or <a data-lt="string">RDF string</a>,
      is used to describe an ordered sequence of zero or more
      <a data-cite="I18N-GLOSSARY#dfn-code-point" class="lint-ignore">Unicode code points</a>
      which are <a data-cite="I18N-GLOSSARY#dfn-scalar-value" class="lint-ignore">Unicode scalar values</a>.
      Unicode scalar values do not include the
      <a data-cite="I18N-GLOSSARY#dfn-surrogate" class="lint-ignore">surrogate code points</a>.
      Note that most <a>concrete RDF syntaxes</a> require the use
      of the UTF-8 character encoding [[!RFC3629]], 
      and use the `\u0000` or `\U00000000` forms to express certain non-character values.
</p>

    <p>A string is identical to another string if it consists of the same sequence of code points.
      An implementation MAY determine string equality by comparing the
      <a data-cite="I18N-GLOSSARY#dfn-code-unit">code units</a> of two strings
      that use the same <a data-cite="I18N-GLOSSARY#dfn-character-encoding">Unicode character encoding</a>
      (UTF-8 or UTF-16) without decoding the string into a
      <a data-cite="I18N-GLOSSARY#dfn-code-point" class="lint-ignore">Unicode code point</a> sequence.</p>
  </section>
</section>

<section id="section-rdf-graph">
  <h2>RDF Graphs</h2>

  <p>An <dfn>RDF graph</dfn> is a set of <a>RDF triples</a>.</p>

  <p>An [=RDF triple=] is said to be <dfn id="dfn-asserted-triple" class=export data-lt="asserted triple|asserted triples" data-lt-no-plural=""
      >asserted</dfn> in an [=RDF graph=] if it is an element of the [=RDF graph=].
  </p>

  <section id="section-triples">
    <h3>Triples</h3>

    <p>An <dfn data-local-lt="triple" class="export">RDF triple</dfn>
     (often simply called "triple")
     is a 3-tuple that is defined inductively as follows:</p>

    <ul>
      <li>
        If |s| is an [=IRI=] or a [=blank node=],
        |p| is an [=IRI=], and
        |o| is an [=IRI=], a [=blank node=], or a [=literal=],
        then (|s|, |p|, |o|) is an [=RDF triple=].
      </li>

      <li>
        If |s| is an [=IRI=] or a [=blank node=],
        |p| is an [=IRI=], and
        |o| is an [=RDF triple=],
        then (|s|, |p|, |o|) is an [=RDF triple=].
      </li>
    </ul>

    <p>The three components (|s|, |p|, |o|) of an [=RDF triple=] are respectively called the <dfn class=export >subject</dfn>, <dfn class=export >predicate</dfn> and <dfn class=export >object</dfn> of the triple.</p>

    <p><dfn>Triple equality</dfn>:
      Two triples (|s|, |p|, |o|) and (<var>s'</var>, <var>p'</var>, <var>o'</var>)
      are equal (the same [=RDF triple=]) if and only if all of the following three conditions hold.</p>

    <ul>
      <li>|s| and <var>s'</var> are [=RDF term equality|equal=].</li>
      <li>|p| and <var>p'</var> are [=RDF term equality|equal=].</li>
      <li>|o| and <var>o'</var> are [=RDF term equality|equal=].</li>
    </ul>


    <p class="note">The definition of <a>triple</a> is recursive.
      That is, a <a>triple</a> can itself have an
      <a>object</a> component which is another <a>triple</a>.
      However, by this definition, cycles of <a>triples</a> cannot be created.</p>
  </section>

  <section id="section-terms">
    <h3>RDF Terms</h3>

    <p><a>IRIs</a>, <a>literals</a>,
      <a>blank nodes</a>, and <a>triple terms</a> are collectively known as
      <span id="dfn-rdf-terms"><!-- obsolete term--></span><dfn data-lt="rdf term">RDF terms</dfn>.</p>

    <p><a>IRIs</a>, <a>literals</a>,
      <a>blank nodes</a>, and <a>triple terms</a> are distinct and distinguishable.
      For example, a literal with the string <code>http://example.org/</code> as
      its <a>lexical form</a>
      is not equal to the IRI <code>http://example.org/</code>,
      nor to a blank node with the <a>blank node identifier</a>
      <code>http://example.org/</code>.</p>

    <p><dfn>RDF term equality</dfn>:
      Two [=RDF terms=] |t| and <var>t'</var> are equal (the same [=RDF term=]) if and only if
      one of the following four conditions holds:</p>

    <ul>
      <li>|t| and <var>t'</var> are [=IRIs=] that are [=IRI equality|equal=] (per [=IRI equality=]).</li>
      <li>|t| and <var>t'</var> are [=literals=] that are [=literal term equality|equal=] (per [=literal term equality=]).</li>
      <li>|t| and <var>t'</var> are [=blank nodes=] that are [=blank node equality|equal=] (per [=blank node equality=]).</li>
      <li>|t| and <var>t'</var> are [=triple terms=] that are [=triple equality|equal=] (per [=triple equality=]).</li>
    </ul>

    <p>The set of <span id="dfn-nodes"><!-- obsolete term--></span><dfn data-lt="node">nodes</dfn> of an <a>RDF graph</a>
      is the set of <a>subjects</a> and <a>objects</a> of the <a>asserted triples</a> of the graph.
      It is possible for a [=predicate=] [=IRI=] to also occur as a [=node=] in
      the same graph.</p>
  </section>

  <section id="section-IRIs">
    <h3>IRIs</h3>

    <p>An <dfn data-lt="iri"><abbr title="Internationalized Resource Identifier">IRI</abbr></dfn>
      (Internationalized Resource Identifier) within an RDF graph
      is a <a>string</a> that conforms to the syntax
      defined in RFC 3987 [[!RFC3987]].</p>

    <p>An IRI in the RDF abstract syntax 
      MUST be <a data-cite="RFC3986#section-5">resolved</a> per [[RFC3986]] and
      MUST NOT be a <a data-cite="RFC3986#section-4.2">relative reference</a>.
      An IRI MAY contain a <a data-cite="RFC3986#section-3.5">fragment identifier</a>.
      An IRI SHOULD follow rules defined by the <a data-cite="RFC3986#section-3.1">IRI scheme</a>.
    </p>

    <p><dfn>IRI equality</dfn>:
      Two IRIs are equal if and only if they consist of the same sequence of
      <a data-cite="I18N-GLOSSARY#dfn-code-point" class="lint-ignore">Unicode code points</a>,
      as in Simple String Comparison in
      <a data-cite="rfc3987#section-5.3.1">section 5.3.1</a> of [[!RFC3987]].
      (This is done in the abstract syntax, so the IRIs are resolved
      IRIs with no escaping or encoding.)
      Further normalization MUST NOT be performed before this comparison. </p>

    <p class="note">For convenience, a complete [[ABNF]] grammar
      from [[RFC3987]] is provided in <a href="#iri-abnf" class="sectionRef"></a>.</p>

    <div class="note" id="note-iris">
      <p><strong>URIs and IRIs:</strong>
        IRIs are a generalization of
        <dfn data-lt="URI" data-lt-noDefault><abbr title="Uniform Resource Identifier">URI</abbr>s</dfn>
        [[RFC3986]] that permits a wider range of Unicode characters [[UNICODE]].
        Every URI and URL is an IRI, but not every IRI is an URI.
        In RDF, IRIs are used as <dfn data-lt="iri reference">IRI references</dfn>, as defined in [[RFC3987]]
        <a data-cite="RFC3987#section-1.3">section 1.3</a>.
        An IRI reference is common usage of an Internationalized Resource Identifier.
        An IRI reference refers to either a resolved <a>IRI</a> or <a>relative IRI reference</a>,
        as described by the <em>IRI-reference</em> production in <a href="#iri-abnf" class="sectionRef"></a>.
        The abstract syntax uses only fully resolved <a>IRIs</a>.
        When IRIs are used in operations that are only
        defined for URIs, they must first be converted according to
        the mapping defined in
        <a data-cite="rfc3987#section-3.1">section 3.1</a>
        of [[!RFC3987]]. A notable example is retrieval over the HTTP
        protocol. The mapping involves UTF-8 encoding of non-ASCII
        characters, %-encoding of octets not allowed in URIs, and
        Punycode-encoding of domain names.</p>

      <p><strong>URLs:</strong>
        The [[[URL]]] is largely compatible with [[RFC3987]] IRIs,
        but is based on a processing model important for implementation
        within web browsers and are not described using an [[ABNF]] grammar.
      </p>

      <p><strong>Relative IRI references:</strong>
        Some <a>concrete RDF syntaxes</a> permit
        <span id="dfn-relative-iris"><!-- obsolete term--></span>
        <dfn id="dfn-relative-iri" data-lt="relative iri reference">relative IRI references</dfn> as a convenient shorthand
        that allows authoring of documents independently from their final
        publishing location.
        Relative IRI references must be
        <a data-cite="rfc3986#section-5.2">resolved against</a> a
        <dfn class="export">base IRI</dfn>.
        Therefore, the RDF graph serialized in such syntaxes is well-defined only
        if a <a data-cite="rfc3986#section-5.1">base IRI
        can be established</a> [[RFC3986]].</p>

      <p><strong>URI Schemes:</strong>
        Implementations are encouraged to enforce the scheme-specific rules of
        the common schemes, such as the
        <a data-cite="RFC7230#section-2.7.1">scheme rules for HTTP/HTTPS</a> and the
        <a data-cite="did-core#identifier">DID syntax</a>.
        Implementations ignore URI scheme rules
        for schemes they do not recognize. 
      </p>

      <p><strong>IRI normalization:</strong>
        Interoperability problems can be avoided by minting
        only IRIs that are normalized according to
        <a data-cite="rfc3987#section-5">Section 5</a>
        of [[!RFC3987]]. 
        </p>

      <ul>
        <li>Use lowercase characters in scheme names.</li>
        <li>Only use percent-encoding of characters where required by the IRI syntax.</li>
        <li>Omit the HTTP or HTTPS default port; <code>http://example/</code>
          is preferred over <code>http://example:80/</code>.</li>
        <li>Use uppercase hexadecimal letters within percent-encoding
          triplets;"<code>%3F</code>" is preferred over
          "<code>%3f</code>".</li>
        <li>An empty path in an HTTP IRI
          <code>http://example/</code> is preferred over
          having no path <code>http://example</code>.</li>
        <li>Normalize IRIs to remove "<code>/./</code>" and "<code>/../</code>" in the path
          component of an IRI.</li>  
        <li>Use lowercase characters in domain names. 
          Note that, while ASCII characters in domain names are case-insensitive, 
          non-ASCII characters in domain names are case-sensitive [[RFC5890]].
          Domains are generally only registered with lowercase letters [[RFC5892]].</li>
        <li>Avoid using the 
          <a href="https://datatracker.ietf.org/doc/html/rfc5890#section-2.3.2.1">A-label</a> 
          (ASCII, punycode-encoded name]) for Internationalized Domain Names [[RFC5890]] in IRIs.</li>
        <li>Use IRIs in Unicode [=Normalization Form C=] [[I18N-Glossary]].</li>
      </ul>
    </div>
  </section>

  <section id="section-Graph-Literal">
    <h3>Literals</h3>

    <p>Literals are used for values such as strings, numbers, and dates.</p>

    <p>A <dfn data-local-lt="RDF literal">literal</dfn> in an <a>RDF graph</a> consists of
      two, three, or four elements, as follow:</p>

    <ol>
      <li>A <dfn>lexical form</dfn>, being an [=RDF string=].
      <li>A <dfn>datatype IRI</dfn>, being an <a>IRI</a>
        identifying a datatype that determines how the lexical form maps
        to a <a>literal value</a>.</li>
      <li>If and only if the <a>datatype IRI</a> is
        <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#langString</code> or
        <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString</code>, a
        non-empty <dfn>language tag</dfn> as defined by [[!BCP47]]. The
        language tag MUST be well-formed according to
        <a data-cite="bcp47#section-2.2.9">section 2.2.9</a>
        of [[!BCP47]],
        and MUST be treated consistently, that is, in a case insensitive manner.
        Two [[!BCP47]]-complying strings that differ only by case represent the same [=language tag=].</li>
      <li>If and only if the <a>datatype IRI</a> is
        <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString</code>,
        a <dfn>base direction</dfn> that MUST be one of the following:<ul>
          <li>`ltr`, indicating that the initial text direction is set to left-to-right</li>
          <li>`rtl`, indicating that the initial text direction is set to right-to-left</li>
        </ul></li>
    </ol>

    <p>A literal is a <dfn>language-tagged string</dfn> if the third element
      is present and the fourth element is not present.
      A literal is a <dfn id="dfn-dir-lang-string">directional language-tagged string</dfn>
      if both the third element and fourth elements are present.
    </p>

    <p><dfn data-local-lt="term-equal">Literal term equality</dfn>:
      two literals are term-equal (the same <a>RDF term</a>)
      if and only if the following are all true:</p>

    <ul>
      <li>The two <a>lexical forms</a> compare equal.</li>
      <li>The two <a>datatype IRIs</a> compare equal.</li>
      <li>The two <a>language tags</a> are either both absent, or both present and compare equal.</li>
      <li>The two <a>base directions</a> are either both absent, both `ltr`, or both `rtl`.</li>
    </ul>
    <p>Comparison of the [=lexical forms=] and of the [=datatype IRIs=] is performed using
      <a data-cite="I18N-GLOSSARY#dfn-case-sensitive">case sensitive matching</a>
      (see description of string comparison in
      <a href="#rdf-strings" class="sectionRef"></a>).
      Comparison of the [=language tags=] is performed using
      <a data-cite="I18N-GLOSSARY#dfn-case-sensitive">ASCII case-insensitive matching</a>.
    </p>

    <section>
      <h2>Representation of literals</h2>

      <p>Some concrete syntaxes MAY support
        <dfn data-lt="simple literal" class="export">simple literals</dfn> consisting of only a
        <a>lexical form</a> without any <a>datatype IRI</a>, <a>language tag</a>, or <a>base direction</a>.
        Simple literals are syntactic sugar for abstract syntax
        <a>literals</a>
        with the <a>datatype IRI</a>
        <code>http://www.w3.org/2001/XMLSchema#string</code>
        (which is commonly abbreviated as <code>xsd:string</code>).
      </p>

      <p>
        Similarly, most concrete syntaxes represent
        <a>language-tagged strings</a> and <a>directional language-tagged strings</a> without
        the <a>datatype IRI</a> because it is always either
        <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#langString</code> (<code>rdf:langString</code>)
        or <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString</code> (<code>rdf:dirLangString</code>), respectively.
      </p>

      <p>
        Any [=string=] complying with [[!BCP47]] MAY be used to represent a [=language tag=] in concrete syntaxes or implementations.
        Such strings MAY be case normalized
        (for example, by canonicalizing as defined by
        <a data-cite="bcp47#section-4.5">BCP 47 section 4.5</a>).
        Alternatively, an implementation MAY preserve the case from the original representation,
        provided that it processes it in a case-insensitive manner.
      </p>

      <aside class=note>
        The treatment of language tags has changed between RDF 1.1 and RDF 1.2.
        In RDF 1.1, `"chat"@fr` and `"chat"@FR` represent two distinct terms,
        but implementations may replace either with the other via some form of normalization.
        In RDF 1.2, they represent the exact same literal,
        i.e., the case difference in the concrete syntax does not propagate into the abstract syntax.
        Since many RDF 1.1 implementations do normalize language tags internally, they will not be impacted by this change.
      </aside>

    </section>

    <section>
      <h2>Literal value</h2>

        <p>The <dfn>literal value</dfn> associated with a <a>literal</a> is defined as follows.</p>

      <ul>
        <li>If the literal is a <a>language-tagged string</a>,
          then the literal value is a pair consisting of its <a>lexical form</a>
          and its <a>language tag</a>, in that order.</li>
        <li>If the literal is a <a>directional language-tagged string</a>, then the literal value is
          a tuple of its <a>lexical form</a>, its <a>language tag</a>, and its <a>base direction</a>,
          likewise in that order.</li>
        <li>If the literal's <a>datatype</a> is handled by an RDF implementation, then one of the following applies:
          <ul>
            <li>If the literal's <a>lexical form</a> is in the <a>lexical space</a>
              of the <a>datatype</a>, then the literal value is the result of applying
              the <a>lexical-to-value mapping</a> of the datatype to the
              <a>lexical form</a>.</li>
            <li>Otherwise, the literal is <dfn data-lt-no-plural>ill-typed</dfn> and no literal value can be
               associated with the literal. Such a case produces a semantic
               inconsistency, but it is not <em>syntactically</em> ill-formed.
               Implementations SHOULD accept [=ill-typed=] literals and produce RDF
               graphs from them. Implementations MAY produce warnings when
               encountering [=ill-typed=] literals.</li>
          </ul>
        </li>
        <li>If the literal's <a>datatype IRI</a> is <em>not</em>
          handled by an RDF implementation, then the literal value is
          not defined by this specification. Implementations SHOULD accept
          literals with unknown datatype IRIs and produce RDF graphs from them.
        </li>
      </ul>

      <p>
        It follows from the above that two literals can have the same value
        without being the same <a>RDF term</a>.
        For example:</p>

      <pre>
        "1"^^xsd:integer
        "01"^^xsd:integer
      </pre>

      <p>denote the same <a data-lt="literal value">value</a>, but are not the
        same literal <a>RDF term</a> because their
        <a>lexical forms</a> differ.</p>
    </section>
  </section>

  <section id="section-blank-nodes">
    <h3>Blank Nodes</h3>

    <p><dfn data-lt="blank node">Blank nodes</dfn> are disjoint from
      <a>IRIs</a> and <a>literals</a>.  Otherwise,
      the set of possible blank nodes is arbitrary.  RDF makes no reference to
      any internal structure of blank nodes.</p>

    <p><dfn>Blank node equality</dfn>:
      Two blank nodes are equal if and only if they are the same blank node.</p>

    <div class="note" id="note-bnode-id">
      <p><span id="dfn-blank-node-identifiers"><!-- obsolete term--></span><dfn data-lt="blank node identifier">Blank node identifiers</dfn>
      are local identifiers that are used in some
      <a>concrete RDF syntaxes</a>
      or RDF store implementations.
      They are always locally scoped to the file or RDF store,
      and are <em>not</em> persistent or portable identifiers
      for blank nodes. Blank node identifiers are <em>not</em>
      part of the RDF abstract syntax, but are entirely dependent
      on the concrete syntax or implementation. The syntactic restrictions
      on blank node identifiers, if any, therefore also depend on
      the concrete RDF syntax or implementation.  Implementations that handle blank node
      identifiers in concrete syntaxes need to be careful not to create the
      same blank node from multiple occurrences of the same blank node identifier
      except in situations where this is supported by the syntax.</p>

      <p>The term "blank node label" is sometimes used informally
      as an alternative to the term <a>blank node identifier</a>.
      This alternative was also used in earlier versions of
      some RDF-related specifications such as [[SPARQL11-QUERY]].
      In the interest of consistency, the use of this alternative
      term is discouraged now.</p>
    </div>
  </section>

  <section id="section-triple-terms">
    <h3>Triple Terms</h3>

    <p>An [=RDF triple=] used as the [=object=] of another [=triple=] is called a <dfn class=export >triple term</dfn>.
      In a given [=RDF graph=], a [=triple=] can appear as a [=triple term=], an [=asserted triple=], or both.
    </p>

    <p>The set of [=RDF terms=] <dfn class=export data-lt="appear">appearing</dfn> in an [=RDF triple=] |t| is defined inductively as follows:</p>

    <ul>
      <li>The [=subject=], [=predicate=] and [=object=] of |t| [=appear=] in |t|.
      <li>If a [=triple term=] |t2| appears in |t|, then any [=RDF term=] [=appearing=] in |t2| also [=appears=] in |t|.
    </ul>

    <p>By extension, an [=RDF term=] is said to [=appear=] in an [=RDF graph=] if it appears in an [=asserted triple=] of that graph. An [=RDF triple=] is said to [=appear=] in an [=RDF graph=] if it is either an [=asserted triple=] of that graph or a [=triple term=] [=appearing=] in that graph.</p>

    <p>Triple term equality:
      Since triple terms are [=triples=], equality of triple terms is the same as [=triple equality=].</p>
      
    <p class="note">Every <a>triple</a> with a <a>triple term</a> as its [=object=] SHOULD
      use <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#reifies</code> (<code>rdf:reifies</code>)
      as its <a>predicate</a>.
      Every <a>triple</a> whose <a>object</a> is not a <a>triple term</a> SHOULD NOT
      use <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#reifies</code> (<code>rdf:reifies</code>)
      as its <a>predicate</a>.</p>
  </section>

  <section id="graph-isomorphism">
    <h3>Graph Comparison</h3>

    <p>This section introduces a notion of graph isomorphism for [=RDF graphs=]
      which is based on a mapping between [=RDF terms=]
      that maps blank nodes to blank nodes
      and is the identity function for IRIs and literals.</p>

    <p>A function |M| from the set of all [=RDF terms=] into that same set
      is called an <dfn>isomorphic RDF-term mapping</dfn>
      if it is has all of the following properties:</p>

    <ul>
      <li>|M| is bijective.</li>
      <li>For every [=blank node=] |b|, |M|(|b|) is a [=blank node=] (but not necessarily the same as |b|).</li>
      <li>For every [=literal=] |lit|, |M|(|lit|) is |lit|.</li>
      <li>For every [=IRI=] |iri|, |M|(|iri|) is |iri|.</li>
      <li>For every [=triple term=] |tt| of the form (|s|, |p|, |o|), |M|(|tt|) is the triple term ( |M|(|s|), |M|(|p|), |M|(|o|) ).</li>
    </ul>

    <p id="section-graph-equality">Two [=RDF graphs=] |G| and <var>G'</var> are
      <dfn data-lt="graph isomorphism|isomorphic" data-lt-noDefault class="export">isomorphic</dfn>
      (that is, they have the same form)
      if there exists an [=isomorphic RDF-term mapping=] |M| such that
      the triple (|s|, |p|, |o|) is in |G| if and only if
      the triple ( |M|(|s|), |M|(|p|), |M|(|o|) ) is in <var>G'</var>.</p>

    <p>With this definition, <var>M</var> shows how each blank node
      in <var>G</var> can be replaced with
      a new blank node to give <var>G'</var>. Graph isomorphism
      is needed to support the RDF Test Cases [[RDF11-TESTCASES]] specification.</p>

  </section>

  <section id="section-text-direction" class="informative">
    <h3>Initial Text Direction</h3>

    <p>The <a>base direction</a> of a <a>directional language-tagged string</a>
      provides a means of establishing the initial direction of text,
      including text which is a mixture of right-to-left and left-to-right scripts.
      The [=Unicode Bidirectional Algorithm=] [[?I18N-Glossary]] provides support for automatically rendering
      a sequence of characters in logical order,
      so that they are visually ordered as expected,
      but this is not sufficient to correctly render bidirectional text.</p>

    <p>For example, some text with a language tag "`he`" might be displayed
      in a left-to-right context (such as an English web page) as
      <bdi dir="ltr">פעילות הבינאום, W3C</bdi>, which is incorrect. When provided
      to a user agent including base direction information (such as using
      HTML's `dir` attribute) it can then be correctly presented as:
    </p>
    <div lang="he" dir="rtl">פעילות הבינאום, W3C</div>

    <p>In the absence of an explicit initial text direction,
      the [=Unicode Bidirectional Algorithm=] detects the text direction from the content.
      This depends on the first strongly directional character in the text
      or on the context.
      To avoid [=spillover effects=], users need to employ [=bidi isolation=] 
      whenever text is inserted into a larger document.
      For example,
      &quot;<code>&lt;bdi lang="he"&gt;ספרים בינלאומיים!&lt;/bdi&gt;</code>&quot;
      displays the Hebrew characters in a right-to-left fashion
      — i.e., as &quot;<bdi lang="he">ספרים בינלאומיים!</bdi>&quot;
      — while they would be stored in memory as
      &quot;<bdo dir="ltr" lang="he">ספרים בינלאומיים!</bdo>&quot;</p>
  </section>

  <section id="section-skolemization">
    <h3>Replacing Blank Nodes with IRIs</h3>

    <p>Blank nodes do not have identifiers in the RDF abstract syntax. The
      <a>blank node identifiers</a> introduced
      by some concrete syntaxes have only
      local scope and are purely an artifact of the serialization.</p>

    <p>In situations where stronger identification is needed, systems MAY
      systematically replace some or all of the blank nodes in an RDF graph
      with <a>IRIs</a>.  Systems wishing to do this SHOULD
      mint a new, globally
      unique IRI (a <dfn class="export">Skolem IRI</dfn>) for each blank node so replaced.</p>

    <p>This transformation does not appreciably change the meaning of an
      RDF graph, provided that the Skolem IRIs do not occur anywhere else.
      It does however permit the possibility of other graphs
      subsequently using the Skolem IRIs, which is not possible
      for blank nodes.</p>

    <p>Systems may wish to mint Skolem IRIs in such a way that they can
      recognize the IRIs as having been introduced solely to replace blank
      nodes. This allows a system to map IRIs back to blank nodes
      if needed.</p>

    <p>Systems that want Skolem IRIs to be recognizable outside of the system
      boundaries SHOULD use a well-known IRI [[RFC8615]] with the registered
      name <code>genid</code>. This is an IRI that uses the HTTP or HTTPS scheme,
      or another scheme that has been specified to use well-known IRIs; and whose
      path component starts with <code>/.well-known/genid/</code>.

    <p>For example, the authority responsible for the domain
      <code>example.com</code> could mint the following recognizable Skolem IRI:</p>

    <pre>http://example.com/.well-known/genid/d26a2d0e98334696f4ad70a677abc1f6</pre>

    <p class="note">RFC 8615 [[RFC8615]] only specifies well-known URIs,
      not IRIs. For the purpose of this document, a well-known IRI is any
      IRI that results in a well-known <a>URI</a> after IRI-to-URI mapping [[!RFC3987]].</p>
  </section>

</section>

<section id="section-dataset">
  <h2>RDF Datasets</h2>

  <p>An <dfn>RDF dataset</dfn> is a collection of
    <a>RDF graphs</a>, and comprises:</p>

  <ul>
    <li>Exactly one <dfn>default graph</dfn>, being an <a>RDF graph</a>.
      The default graph does not have a name and MAY be empty.</li>
    <li>Zero or more <span id="dfn-named-graphs"><!-- obsolete term--></span><dfn data-lt="named graph">named graphs</dfn>.
      Each named graph is a pair consisting of an <a>IRI</a> or a blank node
      (the <dfn>graph name</dfn>), and an <a>RDF graph</a>.
      Graph names are unique within an RDF dataset.</li>
  </ul>

  <p><a>Blank nodes</a> can be shared between graphs
    in an <a>RDF dataset</a>.</p>

  <div class="note" id="note-datasets">
    <p>Despite the use of the word “name” in “<a>named graph</a>”, the
      <a>graph name</a> is not required to <a>denote</a> the graph. It is
      merely syntactically paired with the graph. RDF does not place any
      formal restrictions on what <a>resource</a> the graph name may denote,
      nor on the relationship between that resource and the graph.
      A discussion of different RDF dataset semantics can be found in
      [[RDF11-DATASETS]].</p>

    <p>Some <a>RDF dataset</a> implementations do not
      track empty <a>named graphs</a>. Applications
      can avoid interoperability issues by not ascribing importance to
      the presence or absence of empty named graphs.</p>

    <p>SPARQL version 1.2 [[SPARQL12-CONCEPTS]] uses 
      <a data-cite="SPARQL12-QUERY#sparqlDataset">the same concept of an RDF Dataset</a>
      as RDF versions 1.1 and 1.2,
      in which the graph names of named graphs may be IRIs or blank nodes.
      In contrast, version 1.1 of the SPARQL Query Language [[SPARQL11-QUERY]]
      only allowed graph names to be IRIs.</p>

  </div>

  <section id="section-dataset-isomorphism">
    <h3>RDF Dataset Comparison</h3>

    <p id="section-dataset-equality">Two <a>RDF datasets</a> |D1| and |D2|
      (respectively, with [=default graphs=] |DG1| and |DG2| and sets |NG1| and |NG2| of [=named graphs=])
      are <dfn data-lt="dataset isomorphism" class="export">dataset-isomorphic</dfn> if and only if
      there exists an [=isomorphic RDF-term mapping=] |M|
      for which all of the following properties hold:</p>

    <ul>
      <li>The triple (|s|, |p|, |o|) is in |DG1| if and only if
        the triple ( |M|(|s|), |M|(|p|), |M|(|o|) ) is in |DG2|.</li>
      <li>The [=named graph=] (|n|, |G|) is in |NG1| if and only if
        there is a [=named graph=] (<var>n'</var>, <var>G'</var>) in |NG2| such that
        the following are true:
        <ul>
          <li>|M|(|n|) is [=RDF term equality|equal=] to <var>n'</var>.</li>
          <li>For every triple |t|=(|s|, |p|, |o|), it holds that
            |t| is in |G| if and only if
            the triple ( |M|(|s|), |M|(|p|), |M|(|o|) ) is in <var>G'</var>.</li>
        </ul>
      </li>
    </ul>

  </section>

  <section id="section-dataset-conneg" class="informative">
    <h3>Content Negotiation of RDF Datasets</h3>

    <p>Web resources may have multiple representations that are made available via
      <a data-cite="webarch#frag-coneg">content negotiation</a>
      [[WEBARCH]].  A representation may be returned in an RDF serialization
      format that supports the expression of both <a>RDF datasets</a> and
      <a>RDF graphs</a>.  If an <a>RDF dataset</a>
      is returned and the consumer is expecting an <a>RDF graph</a>,
      the consumer is expected to use the <a data-lt="rdf dataset">RDF dataset's</a> default graph.</p>
  </section>

  <section id="section-dataset-quad" class="informative">
    <h3>Dataset as a Set of Quads</h3>

    <p>A <dfn>quad</dfn> is a <a>triple</a> associated with an optional <a>graph name</a>
      and is used when referring to triples within an <a>RDF dataset</a>.
    </p>

    <p>A <a>quad</a> can be represented as a tuple composed of <a>subject</a>, <a>predicate</a>, <a>object</a>,
      and an optional <a>graph name</a>.</p>

    <p>An <a>RDF dataset</a> can be considered to be a set of <a>quads</a>
      where quads with no <a>graph name</a> supply the <a>triples</a> of the <a>default graph</a>,
      and quads with the same graph name
      supply the triples of the <a>named graph</a> with that name.</p>

    <p class="note">Although a <a>quad</a> without a <a>graph name</a>
      consists of the same three components as a <a>triple</a>,
      it is a distinct concept,
      as it specifically captures the notion of a triple within the <a>default graph</a>
      of an <a>RDF dataset</a>.</p>
  </section>
</section>

<section id="section-Datatypes">
  <h2>Datatypes</h2>

  <p>Datatypes are used with RDF <a>literals</a>
    to represent values such as strings, numbers and dates.
    The datatype abstraction used in RDF is compatible with XML Schema
    [[!XMLSCHEMA11-2]]. Any datatype definition that conforms
    to this abstraction MAY be used in RDF, even if not defined
    in terms of XML Schema. RDF re-uses many of the XML Schema
    built-in datatypes, and defines three additional datatypes,
    <code><a>rdf:JSON</a></code>, <code><a>rdf:HTML</a></code>, and <code><a>rdf:XMLLiteral</a></code>.
  </p>

  <p>A <dfn>datatype</dfn> consists of a <a>lexical space</a>,
    a <a>value space</a> and a <a>lexical-to-value mapping</a>, and
    is identified by one or more <a>IRIs</a>.</p>

  <p>The <dfn>lexical space</dfn> of a datatype is a set of <a>strings</a>.</p>

  <p>The <dfn>lexical-to-value mapping</dfn> of a datatype is a set of
    pairs whose first element belongs to the <a>lexical space</a>,
    and the second element belongs to the <dfn>value space</dfn>
    of the datatype. Each member of the lexical space is paired with exactly
    one value, and is a <em>lexical representation</em>
    of that value. The mapping can be seen as a function
    from the lexical space to the value space.</p>

  <p class="note" id="note-lang-strings"><a>Language-tagged strings</a> have the <a>datatype IRI</a>
    <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#langString</code>
    (commonly abbreviated as <code>rdf:langString</code>).
    No datatype is formally defined for this IRI because the definition
    of <a>datatypes</a> does not accommodate
    <a>language tags</a> in the <a>lexical space</a>.
    The <a>value space</a> associated with this datatype IRI is the set
    of all pairs that consist of a string and a language tag.
    Similarly, <a>directional language-tagged strings</a>
    <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString</code>
    (commonly abbreviated as <code>rdf:dirLangString</code>)
    also have a <a>base direction</a> in the value space.
    The <a>value space</a> associated with this datatype IRI is the set
    of all 3-tuples of a string, a language tag and a base direction.
  </p>

  <p>For example, the XML Schema datatype <code>xsd:boolean</code>,
    where each member of the <a>value space</a> has two lexical
    representations, is defined as follows:</p>

  <dl>
    <dt>Lexical space:</dt>
    <dd>{“<code>true</code>”, “<code>false</code>”, “<code>1</code>”, “<code>0</code>”}</dd>
    <dt>Value space:</dt>
    <dd>{<em><strong>true</strong></em>, <em><strong>false</strong></em>}</dd>
    <dt>Lexical-to-value mapping</dt>
    <dd>{
        &lt;“<code>true</code>”, <em><strong>true</strong></em>&gt;,
        &lt;“<code>false</code>”, <em><strong>false</strong></em>&gt;,
        &lt;“<code>1</code>”, <em><strong>true</strong></em>&gt;,
        &lt;“<code>0</code>”, <em><strong>false</strong></em>&gt;,
        }</dd>
  </dl>

  <p>The <a>literals</a> that can be defined using this
    datatype are:</p>

  <table id="tab-boolean-literals" class="simple">
    <caption>This table lists the literals of type xsd:boolean.</caption>
    <tr>
      <th>Literal</th>
      <th>Value</th>
    </tr>
    <tr>
      <td>&lt;“<code>true</code>”, <code>xsd:boolean</code>&gt;</td>
      <td><em><strong>true</strong></em></td>
    </tr>
    <tr>
      <td>&lt;“<code>false</code>”, <code>xsd:boolean</code>&gt;</td>
      <td><em><strong>false</strong></em></td>
    </tr>
    <tr>
      <td>&lt;“<code>1</code>”, <code>xsd:boolean</code>&gt;</td>
      <td><em><strong>true</strong></em></td>
    </tr>
    <tr>
      <td>&lt;“<code>0</code>”, <code>xsd:boolean</code>&gt;</td>
      <td><em><strong>false</strong></em></td>
    </tr>
  </table>

  <section id="xsd-datatypes">
    <h3>The XML Schema Built-in Datatypes</h3>

    <p><a>IRIs</a> of the form
      <code>http://www.w3.org/2001/XMLSchema#<em>xxx</em></code>,
      where <code><em>xxx</em></code>
      is the name of a datatype, denote the built-in datatypes defined in
      <em>[[[XMLSCHEMA11-2]]]</em> [[!XMLSCHEMA11-2]]. The XML Schema built-in types
      listed in the following table are the
      <dfn>RDF-compatible XSD types</dfn>. Their use is RECOMMENDED.</p>

    <p>Readers might note that the only safe datatypes for transferring
      binary information are `xsd:hexBinary` and `xsd:base64Binary`.</p>

    <table id="tab-xsd-datatypes" class="simple">
      <caption>A list of the RDF-compatible XSD types, with short descriptions</caption>
      <tr><th></th><th>Datatype</th><th>Value space (informative)</th></tr>

      <tr><th rowspan="4">Core types</th><td><a data-cite="xmlschema11-2#string"><code>xsd:string</code></a></td><td>Character strings</td></tr>
      <tr><td><a data-cite="xmlschema11-2#boolean"><code>xsd:boolean</code></a></td><td>true, false</td></tr>
      <tr><td><a data-cite="xmlschema11-2#decimal"><code>xsd:decimal</code></a></td><td>Arbitrary-precision decimal numbers</td></tr>
      <tr><td><a data-cite="xmlschema11-2#integer"><code>xsd:integer</code></a></td><td>Arbitrary-size integer numbers</td></tr>

      <tr><th rowspan="2">IEEE floating-point<br />numbers</th>
          <td><a data-cite="xmlschema11-2#double"><code>xsd:double</code></a></td><td>64-bit floating point numbers incl. ±Inf, ±0, NaN</td></tr>
      <tr><td><a data-cite="xmlschema11-2#float"><code>xsd:float</code></a></td><td>32-bit floating point numbers incl. ±Inf, ±0, NaN</td></tr>

      <tr><th rowspan="4">Time and date</th>
          <td><a data-cite="xmlschema11-2#date"><code>xsd:date</code></a></td><td>Dates (yyyy-mm-dd) with or without timezone</td></tr>
      <tr><td><a data-cite="xmlschema11-2#time"><code>xsd:time</code></a></td><td>Times (hh:mm:ss.sss…) with or without timezone</td></tr>
      <tr><td><a data-cite="xmlschema11-2#dateTime"><code>xsd:dateTime</code></a></td><td>Date and time with or without timezone</td></tr>
      <tr><td><a data-cite="xmlschema11-2#dateTimeStamp"><code>xsd:dateTimeStamp</code></a></td><td>Date and time with required timezone</td></tr>

      <tr><th rowspan="8">Recurring and<br />partial dates</th>
          <td><a data-cite="xmlschema11-2#gYear"><code>xsd:gYear</code></a></td><td>Gregorian calendar year</td></tr>
      <tr><td><a data-cite="xmlschema11-2#gMonth"><code>xsd:gMonth</code></a></td><td>Gregorian calendar month</td></tr>
      <tr><td><a data-cite="xmlschema11-2#gDay"><code>xsd:gDay</code></a></td><td>Gregorian calendar day of the month</td></tr>
      <tr><td><a data-cite="xmlschema11-2#gYearMonth"><code>xsd:gYearMonth</code></a></td><td>Gregorian calendar year and month</td></tr>
      <tr><td><a data-cite="xmlschema11-2#gMonthDay"><code>xsd:gMonthDay</code></a></td><td>Gregorian calendar month and day</td></tr>
      <tr><td><a data-cite="xmlschema11-2#duration"><code>xsd:duration</code></a></td><td>Duration of time</td></tr>
      <tr><td><a data-cite="xmlschema11-2#yearMonthDuration"><code>xsd:yearMonthDuration</code></a></td><td>Duration of time (months and years only)</td></tr>
      <tr><td><a data-cite="xmlschema11-2#dayTimeDuration"><code>xsd:dayTimeDuration</code></a></td><td>Duration of time (days, hours, minutes, seconds only)</td></tr>

      <tr><th rowspan="12">Limited-range<br />integer numbers</th>
          <td><a data-cite="xmlschema11-2#byte"><code>xsd:byte</code></a></td><td>-128…+127 (8 bit)</td></tr>
      <tr><td><a data-cite="xmlschema11-2#short"><code>xsd:short</code></a></td><td>-32768…+32767 (16 bit)</td></tr>
      <tr><td><a data-cite="xmlschema11-2#int"><code>xsd:int</code></a></td><td>-2147483648…+2147483647 (32 bit)</td></tr>
      <tr><td><a data-cite="xmlschema11-2#long"><code>xsd:long</code></a></td><td>-9223372036854775808…+9223372036854775807 (64 bit)</td></tr>

      <tr><td><a data-cite="xmlschema11-2#unsignedByte"><code>xsd:unsignedByte</code></a></td><td>0…255 (8 bit)</td></tr>
      <tr><td><a data-cite="xmlschema11-2#unsignedShort"><code>xsd:unsignedShort</code></a></td><td>0…65535 (16 bit)</td></tr>
      <tr><td><a data-cite="xmlschema11-2#unsignedInt"><code>xsd:unsignedInt</code></a></td><td>0…4294967295 (32 bit)</td></tr>
      <tr><td><a data-cite="xmlschema11-2#unsignedLong"><code>xsd:unsignedLong</code></a></td><td>0…18446744073709551615 (64 bit)</td></tr>

      <tr><td><a data-cite="xmlschema11-2#positiveInteger"><code>xsd:positiveInteger</code></a></td><td>Integer numbers &gt;0</td></tr>
      <tr><td><a data-cite="xmlschema11-2#nonNegativeInteger"><code>xsd:nonNegativeInteger</code></a></td><td>Integer numbers ≥0</td></tr>
      <tr><td><a data-cite="xmlschema11-2#negativeInteger"><code>xsd:negativeInteger</code></a></td><td>Integer numbers &lt;0</td></tr>
      <tr><td><a data-cite="xmlschema11-2#nonPositiveInteger"><code>xsd:nonPositiveInteger</code></a></td><td>Integer numbers ≤0</td></tr>

      <tr><th rowspan="2">Encoded binary data</th>
          <td><a data-cite="xmlschema11-2#hexBinary"><code>xsd:hexBinary</code></a></td><td>Hex-encoded binary data</td></tr>
      <tr><td><a data-cite="xmlschema11-2#base64Binary"><code>xsd:base64Binary</code></a></td><td>Base64-encoded binary data</td></tr>

      <tr><th rowspan="7">Miscellaneous<br />XSD types</th>
          <td><a data-cite="xmlschema11-2#anyURI"><code>xsd:anyURI</code></a></td><td>Resolved or relative URI and IRI references</td></tr>
      <tr><td><a data-cite="xmlschema11-2#language"><code>xsd:language</code></a></td><td>Language tags per [[BCP47]]</td></tr>
      <tr><td><a data-cite="xmlschema11-2#normalizedString"><code>xsd:normalizedString</code></a></td><td>Whitespace-normalized strings</td></tr>
      <tr><td><a data-cite="xmlschema11-2#token"><code>xsd:token</code></a></td><td>Tokenized strings</td></tr>
      <tr><td><a data-cite="xmlschema11-2#NMTOKEN"><code>xsd:NMTOKEN</code></a></td><td>XML NMTOKENs</td></tr>
      <tr><td><a data-cite="xmlschema11-2#Name"><code>xsd:Name</code></a></td><td>XML Names</td></tr>
      <tr><td><a data-cite="xmlschema11-2#NCName"><code>xsd:NCName</code></a></td><td>XML NCNames</td></tr>
    </table>

    <p>The <a>lexical-to-value mapping</a> for <a data-cite="xmlschema11-2#float"><code>xsd:float</code></a>
      and <a data-cite="xmlschema11-2#double"><code>xsd:double</code></a>
      MUST use a method consistent with <a data-cite="XMLSCHEMA11-2#f-doubleLexmap">doubleLexicalMap</a>,
      which MUST strictly conform to the rounding method described in
      <a data-cite="XMLSCHEMA11-2#f-floatPtRound">floatPtRound</a> [[XMLSCHEMA11-2]].</p>

    <p>The other built-in XML Schema datatypes are unsuitable
      for various reasons and SHOULD NOT be used:</p>

    <ul>
      <li><a data-cite="xmlschema11-2#QName"><code>xsd:QName</code></a>
        and <a data-cite="xmlschema11-2#ENTITY"><code>xsd:ENTITY</code></a>
        require an enclosing XML document context.</li>
      <li><a data-cite="xmlschema11-2#ID"><code>xsd:ID</code></a>
        and <a data-cite="xmlschema11-2#IDREF"><code>xsd:IDREF</code></a>
        are for cross references within an XML document.</li>
      <li><a data-cite="xmlschema11-2#NOTATION"><code>xsd:NOTATION</code></a>
        is not intended for direct use.</li>
      <li><a data-cite="xmlschema11-2#IDREFS"><code>xsd:IDREFS</code></a>,
        <a data-cite="xmlschema11-2#ENTITIES"><code>xsd:ENTITIES</code></a>
        and <a data-cite="xmlschema11-2#NMTOKENS"><code>xsd:NMTOKENS</code></a>
        are sequence-valued datatypes which do not fit the RDF <a>datatype</a>
        model.</li>
    </ul>

    <p class="note">The <a>value spaces</a>
      of <a data-cite="xmlschema11-2#double"><code>xsd:double</code></a> and
      <a data-cite="xmlschema11-2#float"><code>xsd:float</code></a> do not
      include all decimal numbers. For every literal of
      either of these two datatypes, the value
      of the literal is a value that can be represented as an
      <a href="http://ieeexplore.ieee.org/servlet/opac?punumber=4610933">IEEE 754-2008</a>
      binary floating point representation of the corresponding precision.
      For instance, the literal with
      lexical form `"0.1"` and datatype <a data-cite="xmlschema11-2#float"><code>xsd:float</code></a>
      <a>denotes</a> the number `0.100000001490116119384765625`.
      Rather than <a data-cite="xmlschema11-2#double"><code>xsd:double</code></a>
      or <a data-cite="xmlschema11-2#float"><code>xsd:float</code></a>, the
      datatype <a data-cite="xmlschema11-2#decimal"><code>xsd:decimal</code></a>
      can be used to accurately capture arbitrary decimal numbers.</p>

    <p class="issue" data-number="92"></p>
  </section>

  <section>
    <h3>Datatype IRIs</h3>

    <p>Datatypes are identified by <a>IRIs</a>.</p>
    <p>
      If any IRI of the form
      <code>http://www.w3.org/2001/XMLSchema#xxx</code> is handled by an RDF implementation, it
      MUST refer to the RDF-compatible XSD type named <code>xsd:xxx</code> for
      every XSD type listed in <a href="#xsd-datatypes">section 5.1</a>.</p>

    <p>The datatypes identified by the three IRIs below are defined in
    Appendix&nbsp;<a href="#section-additional-datatypes" class="sectionRef"></a>:</p>

    <ul>
      <li>The IRI <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral</code>
        refers to the datatype <code><a>rdf:XMLLiteral</a></code>.</li>
      <li>The IRI <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML</code>
        refers to the datatype <code><a>rdf:HTML</a></code>.</li>
      <li>The IRI <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON</code>
        refers to the datatype <code><a>rdf:JSON</a></code>.</li>
    </ul>

    <p>RDF implementations are not required to handle all datatypes.
      Any literal typed with a datatype not handled by an RDF implementation
      is treated just like an unknown IRI, i.e., as referring to an unknown thing.
      Applications MAY give a warning message if they are unable to determine the
      referent of an IRI used in a typed literal. RDF implementations SHOULD NOT
      reject a literal with an unknown datatype as either a syntactic or
      semantic error.<p>

    <p>Other specifications MAY impose additional constraints on
      <a>datatype IRIs</a>, for example, require support
      for certain datatypes.</p>

    <p class="note">Semantic extensions of RDF might choose to
      recognize other datatype IRIs
      and require each of them to refer to a fixed datatype.
      See [[[RDF12-SEMANTICS]]] [[RDF12-SEMANTICS]] for more information on
      semantic extensions.</p>

    <p class="note" id="note-custom-datatypes">The Web Ontology Language
      [[OWL2-OVERVIEW]] offers facilities for formally defining
      <a data-cite="OWL2-SYNTAX#Datatype_Definitions">custom
      datatypes</a> that can be used with RDF. Furthermore, a practice for
      identifying
      <a data-cite="swbp-xsch-datatypes#sec-userDefined">
      user-defined simple XML Schema datatypes</a>
      is suggested in [[SWBP-XSCH-DATATYPES]]. RDF implementations
      are not required to support either of these facilities.</p>

    <p class="note" id="note-recognized-datatype-iris">
      In RDF 1.1, <em><span id="dfn-recognized-datatype-iris">Recognized datatype IRIs</span></em>
      were defined in RDF Concepts, overlapping with 
      <a data-cite="RDF12-SEMANTICS#dfn-recognize">RDF Semantics, "recognizing"</a>
      datatype IRIs for <a data-cite="RDF12-SEMANTICS#dfn-semantic-extension">semantic extensions</a>.
    </p>

  </section>
</section>

<section id="section-fragID" class="informative">
  <h2>Fragment Identifiers</h2>

  <p>RDF uses <a>IRIs</a>, which may include
    <span id="dfn-fragment-identifiers"><!-- obsolete term--></span>
    <dfn data-lt="fragment identifier" class="no-export">fragment identifiers</dfn>,
    as resource identifiers.
    The semantics of fragment identifiers is
    <a data-cite="rfc3986#section-3.5">defined in
    RFC 3986</a> [[RFC3986]]: They identify a secondary resource
    that is usually a part of, a view of, defined in, or described in
    the primary resource, and the precise semantics depend on the set
    of representations that might result from a retrieval action
    on the primary resource.</p>

  <p>This section discusses the handling of fragment identifiers
    in representations that encode <a>RDF graphs</a>.</p>

  <p>In RDF-bearing representations of a primary resource, e.g.,
    <code>&lt;https://example.com/foo&gt;</code>,
    the secondary resource identified by a fragment identifier, e.g., <code>bar</code>,
    is the <a>resource</a> <a>denoted</a> by the
    full <a>IRI</a> in the <a>RDF graph</a>, which would be <code>&lt;https://example.com/foo#bar&gt;</code> in this case.
    Since IRIs in RDF graphs can denote anything, this can be
    something external to the representation, or even external
    to the web.</p>

  <p>In this way, the RDF-bearing representation acts as an intermediary
    between the web-accessible primary resource, and some set of possibly
    non-web or abstract entities that the <a>RDF graph</a> may describe.</p>

  <p>In cases where other specifications constrain the semantics of
    <a>fragment identifiers</a> in RDF-bearing representations, the encoded
    <a>RDF graph</a> should use fragment identifiers in a way that is consistent
    with these constraints. For example, in an HTML+RDFa document [[HTML-RDFA]],
    a fragment identifier such as <code>chapter1</code> may identify a document section
    via the semantics of HTML's <code>@name</code> or <code>@id</code>
    attributes. Such an <a>IRI</a>, e.g., <code>&lt;#chapter1&gt;</code>, should
    then be taken to <a>denote</a> that same section in any RDFa-encoded
    <a>triples</a> within the same document.
    Similarly, fragment identifiers should be used consistently in resources
    with multiple representations that are made available via
    <a data-cite="webarch/#frag-coneg">content negotiation</a>
    [[WEBARCH]]. For example, if the fragment identifier <code>chapter1</code> identifies a
    document section in an HTML representation of the primary resource, then the
    <a>IRI</a> <code>&lt;#chapter1&gt;</code> should be taken to
    <a>denote</a> that same section in all RDF-bearing representations of the
    same primary resource.</p>
</section>

<section id="section-generalized-rdf" class="informative">
  <h2>Generalizations of RDF Triples, Graphs, and Datasets</h2>

  <p>It is sometimes convenient to loosen the requirements
    on <a>RDF triples</a>.  For example, the completeness
    of the RDFS entailment rules is easier to show with
    a notion of symmetric RDF triples.</p>

  <p>
    A <dfn class="export">symmetric RDF triple</dfn> allows the subject to be
    any <a>RDF term</a> that is allowed in the object position, one of
    an <a>IRI</a>, 
    a <a>blank node</a>,
    a <a>literal</a> 
    or a <a>triple term</a>.
    A <dfn class="export">symmetric RDF graph</dfn> is a set of symmetric RDF triples.
    A <dfn class="export">symmetric RDF dataset</dfn>
    comprises a distinguished symmetric RDF graph, and zero
    or more pairs that each associate an <a>IRI</a> or a <a>blank node</a>
    with a symmetric RDF graph.</p>

   <p>Symmetric RDF triples, graphs, and datasets differ
    from standard normative RDF <a>triples</a>,
    <a data-lt="RDF graph">graphs</a>, and
    <a data-lt="RDF dataset">datasets</a>
    only by allowing <a>IRIs</a>,
    <a>blank nodes</a>,
    <a>literals</a>,
    or <a>triple terms</a>
    in the subject and object positions.</p>

  <p>A <dfn class="export">generalized RDF triple</dfn> is a triple having a subject,
    a predicate, and an object, where each can be an <a>IRI</a>, a
    <a>blank node</a>, a
    <a>triple term</a>, or a
    <a>literal</a>. A
    <dfn class="export">generalized RDF graph</dfn>
    is a set of generalized RDF triples. A
    <dfn class="export">generalized RDF dataset</dfn>
    comprises a distinguished generalized RDF graph, and zero
    or more pairs each associating an <a>IRI</a>,
    a <a>blank node</a>,
    a <a>triple term</a>, or
    a <a>literal</a>
    to a generalized RDF graph.</p>

  <p>Generalized RDF triples, graphs, and datasets differ
    from standard normative RDF <a>triples</a>,
    <a data-lt="RDF graph">graphs</a>, and
    <a data-lt="RDF dataset">datasets</a> only
    by allowing <a>IRIs</a>,
    <a>blank nodes</a>,
    <a>triple terms</a>, and
    <a>literals</a> to appear
    in any position, i.e., as subject, predicate, object, or graph name.</p>

  <p class="note" id="note-generalized-rdf">Any user of
    symmetric or generalized RDF triples, graphs, or datasets needs to be
    aware that these notions are non-standard extensions of
    RDF, and their use may cause interoperability problems.
    There is no requirement for any RDF tool to
    accept, process, or produce anything beyond standard
    normative RDF triples, graphs, and datasets. </p>

</section>


<section id="section-classic-full-interop" class="informative">
  <h2>Interoperability between RDF [=Classic=] and RDF [=Full=]</h2>

  <p class=issue>Should we make this section normative?</p>

  <p>This section provides transformations between [=Full=] [=RDF graphs=] (respectively, [=RDF datasets=]) and [=Classic=] [=RDF graphs=] (respectively, [=RDF datasets=]),
  to provide some level of interoperability between the different classes of <a href="#conformance">Conformance</a>.

  <p class=issue>Should we go even further and aim to provide interoperability between <em>RDF 1.1</em> and RDF 1.2 [=Full=]?</p>

  <p class=issue>AT RISK: The Working Group may decide to replace the terms `rdf:TripleTerm`, `rdf:ttSubject`, `rdf:ttPredicate`, and `rdf:ttObject` used in this section with other terms, possibly in a different namespace.</p>

  <p>These transformation are designed to be:</p>

  <dl>
    <dt>Information preserving</dt>
    <dd>It must be possible to reconstruct the input graph (respectively, dataset) from the output graph (respectively, dataset).
      Note, however, that these transformations are not designed to preserve semantics:
      the output graph is not semantically [=equivalent=] to the input graph,
      at least not in the entailment regimes defined in [[RDF12-SEMANTICS]].
    </dd>
    <dt>Idempotent</dt>
    <dd>Applying a transformation several times to a graph (respectively, dataset) should have the same effect as applying it once.
      Moreover, [=classicizing=] a graph (respectively, dataset) that is already complying with RDF [=Classic=] (i.e., containing no [=triple term=]) must result in the same graph (respectively, dataset).
    </dd>
    <dt>Universal</dt>
    <dd>It should be possible to transform any [=Full=] graph (respectively, dataset) to a [=Classic=] graph (respectively, dataset) using this method.
      There is actually <a href="#section-classicize-caveat">a minor caveat</a> to this property.
    </dd>
  </dl>

  <section id="section-classicize-definition">
    <h2>From [=Full=] to [=Classic=]</h2>

    <p>
      Encoding an [=RDF graph=] to ensure that it is consumable by an RDF [=Classic=] implementation is called <dfn data-lt="classicize|classicized">classicizing</dfn> it.
      [=Classicizing=] consists of repeating the following steps until no [=triple term=] [=appears=] in the graph, and the graph is therefore compliant with RDF [=Classic=]: picking a [=triple term=] <var>tt</var> that [=appears=] in the graph; minting a fresh [=blank node=] <var>b</var>
      (i.e., a blank node not yet in use in the graph); replacing all occurrences of <var>tt</var> [=appearing=] in the graph with <var>b</var>;
      and then adding the following triples to the graph (where <var>s</var>, <var>p</var>, and <var>o</var> are respectively the [=subject=], [=predicate=] and [=object=] of <var>tt</var>):
    </p>
    <ul>
      <li>(<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      <li>(<var>b</var>, `rdf:ttSubject`, <var>s</var>)
      <li>(<var>b</var>, `rdf:ttPredicate`, <var>p</var>)
      <li>(<var>b</var>, `rdf:ttObject`, <var>o</var>)
    </ul>

    <p>Note that this transformation is <em>information preserving</em> only when the input graph either has no [=triple term=] [=appearing=] in it,
      or contains no [=asserted=] triple (<var>b</var>, `rdf:type`, `rdf:TripleTerm`) where <var>b</var> is a [=blank node=].
      Implementations encountering this situation MUST report an error.
      This limitation is discussed in Section <a href="#section-classicize-caveat"></a>.
    </p>

    <p class=note>The blank nodes generated to replace [=triple terms=] should not be confused with the [=reifiers=] that are typically associated with these [=triple terms=].</p>

    <p>
      [=Classicizing=] an [=RDF dataset=] consists of [=classicizing=] its [=default graph=] and each of its [=named graph=].
      In this case, the fresh [=blank node=] assigned to each [=triple term=] must not be used in any graph of the dataset.
    </p>

    <p>
      A detailed algorithm of the transformation is found in Section <a href="#section-classicize-algo"></a>.
    </p>

    <section id="section-classicize-example">
      <h2>Example</h2>

      <p>The examples in this section are expressed in the Turtle concrete syntax [[RDF12-TURTLE]].</p>

      <pre id="ex-classicize-input"
       class="example nohighlight"
       title="An input Full RDF graph"
       data-include="./ex-classicize-input.ttl"
       data-include-format="text"
      ></pre>

      <pre id="ex-classicize-input2"
       class="example nohighlight"
       title="The same graph as above, with reifiers made explicit"
       data-include="./ex-classicize-input2.ttl"
       data-include-format="text"
      ></pre>

      <pre id="ex-classicize-output"
       class="example nohighlight"
       title="The result of classicizing the dataset above"
       data-include="./ex-classicize-output.ttl"
       data-include-format="text"
      ></pre>

    </section>

  </section>

  <section id="section-unclassicize-definition">
    <h2>From [=Classic=] to [=Full=]</h2>

    <p>Reverting a [=classicized=] graph to its original form consists of locating
      each [=asserted=] triple (<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      that has a [=blank node=] <var>b</var> as its subject,
      along with the three associated [=asserted=] triples
      that have the same [=blank node=] <var>b</var> as their subjects, i.e.,
      (<var>b</var>, `rdf:ttSubject`, <var>s</var>),
      (<var>b</var>, `rdf:ttPredicate`, <var>p</var>),
      and (<var>b</var>, `rdf:ttObject`, <var>o</var>);
      removing these four triples from the graph;
      and replacing all remaining occurrences of <var>b</var> [=appearing=] in the graph
      with the triple term (<var>s</var>, <var>p</var>, <var>o</var>).
    </p>

    <p>An implementation MUST report an error if, for a given <var>b</var>,
      it can not unambiguously determine <var>s</var>, <var>p</var>, or <var>o</var>
      (i.e., if one of the properties of <var>b</var>
      — `rdf:ttSubject`, `rdf:ttPredicate`, or `rdf:ttObject` —
      is missing or duplicated).
      An implementation MUST also report an error if the input graph contains
      at the same time a [=triple term=] and an [=asserted triple=]
      (<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      where <var>b</var> is the same [=blank node=].
      Note that none of these situations can occur if the input graph was produced by the [=classicize=] transformation.
    </p>

    <p>To revert a [=classicized=] [=RDF dataset=] to its original form, the transformation above is applied to its [=default graph=] and to each of its [=named graphs=].
    </p>

    <p>Note that this transformation has no effect on any [=RDF graph=] or [=RDF dataset=] that does not use the `rdf:TripleTerm` type,
      including [=Full=] graphs or datasets containing [=triple terms=].
      This makes this transformation <em>idempotent</em> as intended.
    </p>
  </section>

  <section id="section-classicize-caveat">
    <h2>Limitations</h2>

    <p>The two transformations above explicitly do not support graphs or datasets containing at the same time a [=triple term=] and an [=asserted triple=]
      (<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      where <var>b</var> is a [=blank node=].
      This means that the [=classicize=] transformation is not <em>strictly</em> universal.
    </p>

    <p>This limitation should not be an issue in practice.
      The `rdf:TripleTerm` type is unlikely to be in used in any published graph or dataset,
      as it was not defined prior to this specification.
      For this reason, using it would actually have been bad practice.
      For future graphs and datasets, this type should be considered to be reserved for use within the [=classicize=] transformation, and not used otherwise.
    </p>

    <p class=note>
      This is one reason why this transformation introduces new vocabulary terms
      (`rdf:TripleTerm`, `rdf:ttSubject`, `rdf:ttPredicate`, `rdf::ttObject`),
      rather than repurposing the existing <a data-cite="RDF12-SCHEMA#ch_reificationvocab">reification vocabulary</a>
      (`rdf:Statement`, `rdf:subject`, `rdf:predicate`, `rdf:object`).
      Unlike `rdf:TripleTerm`, `rdf:Statement` is known to be found in
      widely used datasets (e.g., <a href="https://www.uniprot.org/">Uniprot</a>),
      so reserving its use for the [=classicize=] transformation was not an option.
    </p>

    <p>Another consequence of this restriction is that implementers will need to be aware and careful when merging graphs in an application that [=classicizes=] graphs or datasets.
      The concern is that merging a [=Full=] [=RDF graph=] containing at least one [=triple term=]
      with a [=classicized=] [=RDF graph=] (which might contain [=blank node=] instances of `rdf:TripleTerm`)
      could result in a "hybrid" graph that cannot be transformed to a consistent [=Full=] nor [=Classic=] [=RDF graph=].
      Therefore, such applications should [=classicize=] every graph prior to merging them.
      Conversely, applications supporting RDF [=Full=] should make sure to apply the reverse transformation
      to any graph that is known or likely to have been [=classicized=],
      to avoid creating such "hybrid" graphs.
      Since these transformations are designed to be <em>idempotent</em>, there is no harm in applying them more than necessary.
    </p>
  </section>

  <section>
    <h2>Algorithms</h2>

    <section id="section-classicize-algo" class="algorithm">
      <h2>The `classicize` algorithm</h2>

      <p>The algorithm expects one input variable <var>Gᵢ</var> which is an [=RDF graph=]. It returns a [=Classic=] [=RDF graph=].
      </p>

      <ol>
        <li>Let <var>Gₒ</var> be an empty [=RDF graph=].</li>
        <li>Let <var>M</var> be an empty map from [=triple terms=] to [=blank nodes=].</li>
        <li>Let <var>inputKind</var> be `null`.</li>
        <li>For each triple (<var>s</var>, <var>p</var>, <var>o</var>) in <var>Gᵢ</var>:<ol>
          <li>If <var>s</var> is a [=blank node=], <var>p</var> is `rdf:type` and <var>o</var> is `rdf:TripleTerm`, then:<ol>
            <li id="classicize-error1">If <var>inputKind</var> is `"full"` then exit with an error.</li>
            <li>Otherwise, set <var>inputKind</var> to `"classic"`.</li>
          </ol></li>
          <li>If <var>o</var> is a [=triple term=], then:<ol>
            <li id="classicize-error2">If <var>inputKind</var> is `"classic"` then exit with an error.</li>
            <li>Otherwise, set <var>inputKind</var> to `"full"`.</li>
            <li>Let <var>b</var>, <var>M'</var> and <var>G'</var> be the result of invoking <a href="#section-ctt-algo">`classicize-triple-term`</a> passing <var>o</var> as <var>t</var> and <var>M</var> as <var>Mi</var>.</li>
            <li>Merge <var>M'</var> into <var>M</var>.
            <li>Merge <var>G'</var> into <var>Gₒ</var>.
            <li>Set <var>o</var> to <var>b</var>.
          </ol></li>
          <li>Add the triple (<var>s</var>, <var>p</var>, <var>o</var>) to <var>Gₒ</var>.</li>
        </ol></li>
        <li>Return <var>Gₒ</var>.</li>
      </ol>
    </section>

    <section id="section-ctt-algo" class="algorithm">
      <h2>The `classicize-triple-term` algorithm</h2>

      <p>This algorithm is responsible for incrementally populating the mapping <var>M</var> and the graph <var>G</var> used internally by the <a href="#section-classicize-algo">`classicize`</a> algorithm. It receives a [=triple term=] as input and processes it recursively (in case its object is itself a [=triple term=]). It returns, among other things, the [=blank node=] minted to replace the [=triple term=] in the transformed [=Classic=] [=RDF graph=].</p>

      <p>This algorithm expects two input variables:
        a [=triple term=] <var>t</var>,
        and a map <var>Mᵢ</var> from [=triple terms=] to [=blank nodes=].
        It returns a [=blank node=] <var>b</var>,
        a map <var>Mₒ</var> from [=triple terms=] to [=blank nodes=],
        and a [=Classic=] [=RDF graph=] <var>G</var>.
      </p>

      <ol>
        <li>Let <var>Mₒ</var> be an empty map.</li>
        <li>Let <var>G</var> be an empty [=RDF graph=].</li>
        <li>Let <var>b</var> be the [=blank node=] associated with <var>t</var> in <var>Mᵢ</var>, if any.
        <li>Otherwise:<ol>
          <li>Let <var>s</var>, <var>p</var> and <var>o</var> be the subject, predicate and object of <var>t</var>, respectively.</li>
          <li>If <var>o</var> is a [=triple term=], then:<ol>
            <li>Let <var>b'</var>, <var>M'</var> and <var>G'</var> be the result of invoking <a href="#section-ctt-algo">`classicize-triple-term`</a> passing <var>o</var> as <var>t</var> and <var>Mᵢ</var>.</li>
            <li>Set <var>o</var> to <var>b'</var>.
            <li>Merge <var>M'</var> into <var>Mₒ</var>.
            <li>Merge <var>G'</var> into <var>G</var>.
          </ol></li>
          <li id="qtt-fresh-bnode">Let <var>b</var> be a fresh blank node.</li>
          <li>Add the association (<var>t</var>, <var>b</var>) to <var>Mₒ</var>.</li>
          <li>Add the triples (<var>b</var>, `rdf:type`, `rdf:TripleTerm`), (<var>b</var>, `rdf:ttSubject`, <var>s</var>), (<var>b</var>, `rdf:ttPredicate`, <var>p</var>), and (<var>b</var>, `rdf:ttObject`, <var>o</var>) in <var>G</var>.</li>
        </ol></li>
        <li>Return <var>b</var>, <var>Mₒ</var> and <var>G</var>.</li>
      </ol>

    </section>

    <section id="section-unclassicize-algo" class="algorithm">
      <h2>The `revert-classicize` algorithm</h2>

      <p class=issue>Write this algorithm</p>
    </section>


  </section>


</section>

<section id="section-additional-datatypes" class="appendix">
  <h2>Additional Datatypes</h2>
  <p>This section defines additional <a>datatypes</a> that RDF implementations MAY support.</p>

  <section id="section-html">
    <h3>The <code>rdf:HTML</code> Datatype</h3>

    <p>RDF provides for HTML content as a possible <a>literal value</a>.
      This allows markup in literal values. Such content is indicated
      in an <a>RDF graph</a> using a <a>literal</a> whose <a>datatype</a>
      is set to <code><dfn>rdf:HTML</dfn></code>.</p>

    <p>The <code>rdf:HTML</code> datatype is defined as follows:</p>

    <dl>
      <dt id="HTML-uri">The IRI denoting this datatype</dt>
      <dd>is <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML</code>.</dd>

      <dt id="HTML-value-space">The <a>value space</a></dt>
      <dd>is the set of DOM
        <a data-cite="DOM#interface-documentfragment"><code>DocumentFragment</code></a>
        nodes [[DOM]]. Two
        <a data-cite="DOM#interface-documentfragment"><code>DocumentFragment</code></a>
        nodes <var>node</var> and <var>otherNode</var> are considered equal if and only if
        the DOM method
        <code><var>node</var>.{{Node/isEqualNode(otherNode)}}</code>
        [[DOM]] returns <code>true</code>.</dd>

      <dt id="HTML-mapping">The lexical-to-value mapping</dt>
      <dd>
        <p>Each member of the lexical space is associated with the result
          of applying the following algorithm:</p>
        <ul>
          <li>Let <code>domnodes</code> be the list of <a data-cite="DOM#node">DOM nodes</a> [[DOM]]
            that result from applying the
            <a data-cite="HTML5#parsing-html-fragments">HTML fragment parsing algorithm</a> [[HTML5]]
            to the input string, without a context element.</li>
          <li>Let <code>domfrag</code> be a DOM
            <a data-cite="DOM#interface-documentfragment"><code>DocumentFragment</code></a> [[DOM]]
            whose <code>childNodes</code> attribute is equal to <code>domnodes</code></li>
            <li>Return <code>domfrag.{{Node/normalize()}}</code>.</li>
        </ul>
      </dd>
    </dl>

    <p class="note" id="note-html">
      Any language annotation (<code>lang="…"</code>),
      text directionality annotation (<code>dir="…"</code>), or
      XML namespaces (<code>xmlns</code>) desired in the HTML content
      must be included explicitly in the HTML literal. Relative URLs
      in attributes such as <code>href</code> do not have a well-defined
      base URL and are best avoided.
      RDF applications may use additional equivalence relations,
      such as that which relates an <code>xsd:string</code> with an
      <code>rdf:HTML</code> literal corresponding to a single text node
      of the same string.</p>
  </section>

  <section id="section-XMLLiteral">
    <h3>The <code>rdf:XMLLiteral</code> Datatype</h3>

    <p>RDF provides for XML content as a possible <a>literal value</a>.
      Such content is indicated in an <a>RDF graph</a> using a <a>literal</a>
      whose <a>datatype</a> is set to <code><dfn>rdf:XMLLiteral</dfn></code>.</p>

    <p>The <code>rdf:XMLLiteral</code> datatype is defined as follows:</p>

    <dl>
      <dt id="XMLLiteral-uri">The IRI denoting this <a>datatype</a></dt>
      <dd>is <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral</code>.</dd>

      <dt id="XMLLiteral-lexical-space">The <a>lexical space</a></dt>
      <dd>is the set of all <a>strings</a> which are well-balanced,
        self-contained <a data-cite="XML11#NT-content">XML content</a> [[XML11]];
        and for which embedding between an arbitrary
        XML start tag and an end tag yields
        a document conforming to [[[XML-NAMES]]] [[XML-NAMES]].</dd>

      <dt id="XMLLiteral-value-space">The <a>value space</a></dt>
        <dd>is the set of DOM
        <a data-cite="DOM#interface-documentfragment"><code>DocumentFragment</code></a>
        nodes [[DOM]]. Two
        <a data-cite="DOM#interface-documentfragment"><code>DocumentFragment</code></a>
        nodes <var>node</var> and <em>otherNode</em> are considered equal if and only if the DOM method
        <code><var>node</var>.{{Node/isEqualNode(otherNode)}}</code>
        returns <code>true</code>.</dd>

      <dt id="XMLLiteral-mapping">The <a>lexical-to-value mapping</a></dt>
      <dd>
        <p>Each member of the lexical space is associated with the result of applying the following algorithm:</p>
        <ul>
          <li>Let <code>domfrag</code> be a DOM
            <a data-cite="DOM#interface-documentfragment"><code>DocumentFragment</code></a>
            node [[DOM]] corresponding to the input string.</li>
          <li>Return <code>domfrag.{{Node/normalize()}}</code>.</li>
        </ul>
      </dd>
    </dl>

    <p class="note">Any XML namespace declarations (<code>xmlns</code>),
      language annotation (<code>xml:lang</code>) or base URI declarations
      (<code>xml:base</code>) desired in the XML content must be included
      explicitly in the XML literal. Note that some concrete RDF syntaxes
      may define mechanisms for inheriting them from the context (e.g.,
      <a data-cite="RDF12-XML#parseTypeLiteralPropertyElt"><code>@parseType="literal"</code></a>
      in RDF/XML [[RDF12-XML]].</p>
  </section>

  <section id="section-json">
    <h3>The <code>rdf:JSON</code> Datatype</h3>

    <p>RDF provides for JSON content as a possible <a>literal value</a>.
      This includes allowing markup in literal values. Such content is indicated in an
      <a>RDF graph</a> as a <a>literal</a> whose <a>datatype</a> is set
      to <code><dfn>rdf:JSON</dfn></code>.</p>

    <p>The <code>rdf:JSON</code> datatype is defined as follows:</p>

    <dl>
      <dt id="JSON-uri">The IRI denoting this <a>datatype</a></dt>
      <dd>is <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#JSON</code>.</dd>

      <dt id="JSON-lexical-space">The <a>lexical space</a></dt>
      <dd>is the set of all <a data-lt="string">RDF strings</a> that conform to the
        <a data-cite="RFC8259#section-2">JSON Grammar</a> as described in
        <a data-cite="RFC8259#section-2">Section&nbsp;2 JSON Grammar</a> of [[RFC8259]],
        which also conform to the requirements of [[[RFC7493]]] [[RFC7493]].
        <div class="note">
          [[[RFC8259]]] [[RFC8259]] allows strings to include
          <a data-cite="I18N-GLOSSARY#dfn-surrogate" class="lint-ignore">surrogate code points</a>
          not allowed in <a data-lt="string">RDF strings</a>,
          which are also excluded in [[RFC7493]],
          thus the lexical representation of JSON literals excludes those including
          <a data-cite="I18N-GLOSSARY#dfn-surrogate" class="lint-ignore">surrogate code points</a>.
        </div></dd>

      <dt id="JSON-value-space">The <a>value space</a></dt>
      <dd>is the smallest set containing
        <a>strings</a>,
        numbers (<a data-cite="XMLSCHEMA11-2#double"><strong>xsd:double</strong></a>),
        <a data-cite="INFRA#ordered-map">maps</a>
        (mapping <a>strings</a> to values in the <a href="#JSON-value-space">value space</a> where the order of <a data-cite="INFRA#map-entry">map entries</a> is not significant),
        <a data-cite="INFRA#list">lists</a>
        (of values in the <a href="#JSON-value-space">value space</a>), and
        literal values (<a data-cite="INFRA#boolean">`true`, `false`</a>, and <a data-cite="INFRA#nulls">`null`</a>)
        from [[[INFRA]]] [[INFRA]] and [[[XMLSCHEMA11-2]]] [[XMLSCHEMA11-2]].

        <p class="note">The value space of <a data-cite="INFRA#ordered-map">maps</a>
          and <a data-cite="INFRA#list">lists</a> does not include values having themselves as members,
          which cannot be represented in JSON.</p>

        <p>Two values (|a| and |b|) are considered equal if any of the following are true:
          <ul>
            <li>They are the same <a>string</a>,
              number (<a data-cite="XMLSCHEMA11-2#double"><strong>xsd:double</strong></a>), or
              literal value.</li>
            <li>They are both <a data-cite="INFRA#list">lists</a> containing <a data-cite="INFRA#list-item">items</a>
              which are pairwise equal – meaning that each <a data-cite="INFRA#list-item">item</a>
              in |a| is equal the <a data-cite="INFRA#list-item">item</a>
              at the corresponding index in |b|,
              and both |a| and |b| have the same <a data-cite="INFRA#list-size">size</a>.</li>
            <li>They are both <a data-cite="INFRA#ordered-map">maps</a> with equal <a data-cite="INFRA#map-entry">entries</a>
              – meaning that for each entry <var>e<sub>a</sub></var> in |a|
              there exists an entry <var>e<sub>b</sub></var> in |b|
              such that the <a data-cite="INFRA#map-key">key</a> in <var>e<sub>a</sub></var>
              equals the <a data-cite="INFRA#map-key">key</a> in <var>e<sub>b</sub></var>,
              the <a data-cite="INFRA#map-value">value</a> in <var>e<sub>a</sub></var>
              equals the <a data-cite="INFRA#map-value">value</a> in <var>e<sub>b</sub></var>,
              and both |a| and |b| have the same <a data-cite="INFRA#map-size">size</a>.
              <div class="note">Two JSON Objects containing maps which are serialized with entries in a different order will be equal under this definition when transformed to the value space.
              For example, `{ "a": 1, "b": 2 } and { "b": 2, "a": 1 }` are considered equal.
              As a result of the value space being defined using terminology from [[INFRA]],
              property values which can contain more than one item, such as <a data-cite="INFRA#list">lists</a> and <a data-cite="INFRA#ordered-map">maps</a>,
              are explicitly ordered.
              All list-like value structures in [[INFRA]] are ordered,
              whether or not that order is significant.
              For the purposes of this specification, unless otherwise stated,
              <a data-cite="INFRA#ordered-map">map</a> ordering is not important
              and implementations are not expected to produce or consume deterministically ordered values.
              </div>
            </li>
          </ul>
      </dd> 

      <dt id="JSON-mapping">The <a>lexical-to-value mapping</a></dt>
      <dd>maps every element of the lexical space to the result of parsing it into a
        <a>string</a>,
        number (<a data-cite="XMLSCHEMA11-2#double"><strong>xsd:double</strong></a>),
        <a data-cite="INFRA#ordered-map">map</a>,
        <a data-cite="INFRA#list">list</a>, or
        literal value (<a data-cite="INFRA#boolean">`true`, `false`</a>, and <a data-cite="INFRA#nulls">`null`</a>).

        <ul>
          <li>A <a data-cite="RFC8259#section-4">JSON Object</a> is mapped to a <a data-cite="INFRA#ordered-map">map</a>
            by transforming each object member into a <a data-cite="INFRA#map-entry">map entry</a>
            with the <a data-cite="INFRA#map-key">key</a> taken from the member name and
            <a data-cite="INFRA#map-value">value</a> taken by performing this mapping
            to the member value.
            <a data-cite="INFRA#map-entry">Map entries</a> are treated as being unordered.
          </li>
          <li>A <a data-cite="RFC8259#section-5">JSON Array</a> is mapped to a <a data-cite="INFRA#list">list</a>
            such that this <a data-cite="INFRA#list">list</a> contains as many
            elements as the <a data-cite="RFC8259#section-5">JSON Array</a> and, for
            every position |i| in the <a data-cite="RFC8259#section-5">array</a>,
            the element at the |i|-th position in the
            <a data-cite="INFRA#list">list</a> is the value that results from
            applying this mapping to the |i|-th element of the
            <a data-cite="RFC8259#section-5">array</a>.</li>
          <li>A <a data-cite="RFC8259#section-6">JSON Number</a> is mapped to
            an <a data-cite="XMLSCHEMA11-2#double"><strong>xsd:double</strong></a>
            using a method consistent with <a data-cite="XMLSCHEMA11-2#f-doubleLexmap">doubleLexicalMap</a>,
            which MUST strictly conform to the rounding method described in
            <a data-cite="XMLSCHEMA11-2#f-floatPtRound">floatPtRound</a> [[XMLSCHEMA11-2]].
            <div class="note">Some numbers cannot be represented
              as finite <a data-cite="XMLSCHEMA11-2#double"><strong>xsd:double</strong></a> values
              and may map to `+INF` or `-INF`.
              Such values cannot be represented as JSON Numbers, limiting the ability to serialize such values back to JSON.</div>
          </li>
          <li>A <a data-cite="RFC8259#section-7">JSON String</a> is mapped to
            a <a>string</a> after converting any escape sequences to the associated
            <a data-cite="I18N-GLOSSARY#dfn-code-point">Unicode code point</a>.</li>
          <li>A <a data-cite="RFC8259#section-3">JSON literal name</a> maps
            JSON `true`, `false`, and `null` values
            to [[INFRA]] <a data-cite="INFRA#boolean">`true`</a>,
            <a data-cite="INFRA#boolean">`false`</a>, and
            <a data-cite="INFRA#nulls">`null`</a> values, respectively.</li>
        </ul>
      </dd>
    </dl>
    <p class="issue" data-number="116">The issue refers to the use
      of <a data-cite="INFRA#ordered-map">ordered map</a>
      from [[INFRA]] for describing the value space of <a data-cite="RFC8259#section-4">JSON Objects</a>
      and suggests defining a new datatype for unordered maps.</p>
  </section>

</section>

<section id="privacy" class="appendix informative">
  <h2>Privacy Considerations</h2>
  <p>RDF is used to express arbitrary application data,
    which may include the expression of personally identifiable information (PII)
    or other information which could be considered sensitive.
    Authors publishing such information are advised to carefully
    consider the needs and use of publishing such information,
    as well as the applicable regulations for the regions where the data is
    expected to be consumed and potentially revealed (e.g., 
    <a href="https://gdpr.eu/">GDPR</a>, 
    <a href="https://oag.ca.gov/privacy/ccpa">CCPA</a>,
    <a href="https://termly.io/resources/infographics/privacy-laws-around-the-world/">others</a>),
    particularly whether authorization measures are needed for access to the data.</p>
</section>

<section id="security" class="appendix informative">
  <h2>Security Considerations</h2>

  <p>The RDF Abstract Syntax is not used directly for conveying information,
    although concrete serialization forms are specifically intended to do so.</p>

  <p>Applications MAY evaluate given data to infer more assertions or to dereference <a>IRIs</a>,
    invoking the security considerations of the scheme for that IRI.
    Note in particular, the privacy issues in [[RFC3023]] section 10 for HTTP IRIs.
    Data obtained from an inaccurate or malicious data source may lead to inaccurate or misleading conclusions,
    as well as the dereferencing of unintended IRIs.
    Care must be taken to align the trust in consulted resources with the sensitivity of
    the intended use of the data;
    inferences of potential medical treatments would likely require different trust than inferences
    for trip planning.</p>

  <p>RDF is used to express arbitrary application data;
    security considerations will vary by domain of use.
    Security tools and protocols applicable to text
    (for example, PGP encryption, checksum validation, password-protected compression)
    may also be used on RDF documents.
    Security/privacy protocols must be imposed which reflect the sensitivity of the embedded information.</p>

  <p>RDF can express data which is presented to the user, such as RDF Schema labels.
    Applications rendering <a>strings</a> retrieved from untrusted RDF documents,
    or using unescaped characters,
    SHOULD use warnings and other appropriate means to limit the possibility
    that malignant strings might be used to mislead the reader.
    The security considerations in the media type registration for XML ([[RFC3023]] section 10)
    provide additional guidance around the expression of arbitrary data and markup.</p>

  <p>RDF uses <a>IRIs</a> as term identifiers.
    Applications interpreting data expressed in RDF SHOULD address the security issues of
    [[[RFC3987]]] [[RFC3987]] Section 8, as well as
    [[[RFC3986]]] [[RFC3986]] Section 7.</p>

  <p>Multiple <a>IRIs</a> may have the same appearance.
     Characters in different scripts may look similar (for instance,
     a Cyrillic &quot;&#1086;&quot; may appear similar to a Latin &quot;o&quot;).
     A character followed by combining characters may have the same visual representation
     as another character (for example, LATIN SMALL LETTER "E" followed by COMBINING ACUTE
     ACCENT has the same visual representation as LATIN SMALL LETTER "E" WITH ACUTE).
     Any person or application that is writing or interpreting data in RDF
     must take care to use the IRI that matches the intended semantics,
     and avoid IRIs that may look similar.
     Further information about matching visually similar characters can be found
     in [[[UNICODE-SECURITY]]] [[UNICODE-SECURITY]] and
     [[[RFC3987]]] [[RFC3987]] Section 8.</p>

  <p class="note">These considerations are a more generic form
    of Security Considerations for [[RDF12-TURTLE]], [[RDF12-TRIG]], [[RDF12-N-TRIPLES]],
    and [[RDF12-N-QUADS]].</p>
</section>

<section id="internationalization" class="appendix informative">
  <h2>Internationalization Considerations</h2>
  <p>Unicode [[UNICODE]] provides a mechanism for signaling direction within a string
    (see [=Unicode Bidirectional Algorithm=] [[I18N-Glossary]]).
    RDF provides a mechanism for specifying the <a>base direction</a>
    of a <a>directional language-tagged string</a>
    to signal the initial text direction of a string.
    For most human language strings, but particularly for those
    whose base direction cannot be accurately determined from the 
    string content, is it valuable to have an external indicator in order
    to get the proper display and isolation of the value.
    One example of such an indicator is
    the [[HTML]] <a data-cite="HTML/dom.html#the-dir-attribute">dir attribute</a>;
    see [[STRING-META]].</p>

  <p>[[[JSON-LD11]]] [[JSON-LD11]] introduced the
    <a data-cite="JSON-LD11#the-i18n-namespace">i18n namespace</a> to use
    a datatype to specify both the base direction an <a>language tag</a>
    of an <a>RDF literal</a>.</p>
</section>

<section id="iri-abnf" class="appendix informative">
  <h2>IRI Grammar</h2>

  <p>
    The following [[ABNF]] grammar applies the changes from [[RFC3987]] and [[RFC6874]] to the section
    <a data-cite="RFC3986#appendix-A">Collected ABNF for URI</a> of
    [[RFC3986]] to give a consolidated grammar for IRIs.
   </p>
   <p>
    This is provided for convenience only.
    If it differs from definitions in [[RFC3986]], [[RFC3987]], or any subsequent updates,
    then those definitions should be used.
    </p>

  <div class="abnf">
    <pre data-include="iri-grammar.abnf"></pre>
  </div>

  <p>The ABNF can also be accessed directly from <a href="iri-grammar.abnf">iri-grammar.abnf</a>.</p>

</section>

<section id="section-Acknowledgments" class="informative appendix">
  <h2>Acknowledgments</h2>

  <section class="informative">
    <h3>Acknowledgments for RDF 1.0</h3>

    <p>The editors of the original version of the spec were
      Graham Klyne (Nine by Nine) and
      Jeremy J. Carroll (Hewlett Packard Labs).</p>

    <p>This document contains a significant contribution from
      Pat Hayes, Sergey Melnik and Patrick Stickler,
      under whose leadership was developed the framework described in the
      RDF family of specifications for representing datatyped values,
      such as integers and dates.</p>

    <p>The editors acknowledge valuable contributions from the following:
      Frank Manola, Pat Hayes, Dan Brickley, Jos de Roo, Dave Beckett,
      Patrick Stickler, Peter F. Patel-Schneider, Jerome Euzenat, Massimo Marchiori,
      Tim Berners-Lee, Dave Reynolds and Dan Connolly.</p>

    <p>Jeremy Carroll thanks Oreste Signore,
      his host at the W3C Office in Italy and
      Istituto di Scienza e Tecnologie dell'Informazione "Alessandro Faedo",
      part of the Consiglio Nazionale delle Ricerche, where Jeremy is a visiting researcher.</p>

    <p>This document is a product of extended deliberations by the
      RDFcore Working Group,
      whose members have included:
      Art Barstow (W3C), Dave Beckett (ILRT), Dan Brickley (ILRT), Dan Connolly (W3C),
      Jeremy Carroll (Hewlett Packard), Ron Daniel (Interwoven Inc), Bill dehOra (InterX),
      Jos De Roo (AGFA), Jan Grant (ILRT), Graham Klyne (Nine by Nine),
      Frank Manola (MITRE Corporation), Brian McBride (Hewlett Packard),
      Eric Miller (W3C), Stephen Petschulat (IBM), Patrick Stickler (Nokia),
      Aaron Swartz (HWG), Mike Dean (BBN Technologies / Verizon),
      R. V. Guha (Alpiri Inc), Pat Hayes (IHMC), Sergey Melnik (Stanford University) and
      Martyn Horner (Profium Ltd).</p>

    <p>This specification also draws upon an earlier
      RDF Model and Syntax document edited by Ora Lassilla and Ralph Swick,
      and RDF Schema edited by Dan Brickley and R. V. Guha.
      RDF and RDF Schema Working Group members who contributed to this earlier work are:
      Nick Arnett (Verity), Tim Berners-Lee (W3C), Tim Bray (Textuality),
      Dan Brickley (ILRT / University of Bristol), Walter Chang (Adobe), Sailesh Chutani (Oracle),
      Dan Connolly (W3C), Ron Daniel (DATAFUSION), Charles Frankston (Microsoft),
      Patrick Gannon (CommerceNet),
      R. V. Guha (Epinions, previously of Netscape Communications), Tom Hill (Apple Computer),
      Arthur van Hoff (Marimba), Renato Iannella (DSTC), Sandeep Jain (Oracle),
      Kevin Jones, (InterMind), Emiko Kezuka (Digital Vision Laboratories),
      Joe Lapp (webMethods Inc.), Ora Lassila (Nokia Research Center), Andrew Layman (Microsoft),
      Ralph LeVan (OCLC), John McCarthy (Lawrence Berkeley National Laboratory),
      Chris McConnell (Microsoft), Murray Maloney (Grif),
      Michael Mealling (Network Solutions), Norbert Mikula (DataChannel),
      Eric Miller (OCLC), Jim Miller (W3C, emeritus),
      Frank Olken (Lawrence Berkeley National Laboratory), Jean Paoli (Microsoft),
      Sri Raghavan (Digital/Compaq), Lisa Rein (webMethods Inc.),
      Paul Resnick (University of Michigan), Bill Roberts (KnowledgeCite),
      i Tsuyoshi Sakata (Digital Vision Laboratories), Bob Schloss (IBM),
      Leon Shklar (Pencom Web Works), David Singer (IBM), Wei (William) Song (SISU),
      Neel Sundaresan (IBM), Ralph Swick (W3C), Naohiko Uramoto (IBM),
      Charles Wicksteed (Reuters Ltd.), Misha Wolf (Reuters Ltd.) and
      Lauren Wood (SoftQuad).</p>
  </section>

  <section class="informative">
    <h3>Acknowledgments for RDF 1.1</h3>

    <p>The editors of the RDF 1.1 version of the spec were
      Richard Cyganiak (DERI),
      David Wood (3 Round Stones), and
      Markus Lanthaler (Graz University of Technology).</p>

    <p>The editors acknowledge valuable contributions from Thomas Baker,
      Tim Berners-Lee, David Booth, Dan Brickley, Gavin Carothers, Jeremy Carroll,
      Pierre-Antoine Champin, Dan Connolly, John Cowan, Martin J. Dürst,
      Alex Hall, Steve Harris, Sandro Hawke, Pat Hayes, Ivan Herman, Peter F. Patel-Schneider,
      Addison Phillips, Eric Prud'hommeaux, Nathan Rixham, Andy Seaborne, Leif Halvard Silli,
      Guus Schreiber, Dominik Tomaszuk, and Antoine Zimmermann.</p>

    <p>The membership of the RDF Working Group included Thomas Baker,
      Scott Bauer, Dan Brickley, Gavin Carothers, Pierre-Antoine Champin,
      Olivier Corby, Richard Cyganiak, Souripriya Das, Ian Davis, Lee Feigenbaum,
      Fabien Gandon, Charles Greer, Alex Hall, Steve Harris, Sandro Hawke,
      Pat Hayes, Ivan Herman, Nicholas Humfrey, Kingsley Idehen, Gregg Kellogg,
      Markus Lanthaler, Arnaud Le Hors, Peter F. Patel-Schneider,
      Eric Prud'hommeaux, Yves Raimond, Nathan Rixham, Guus Schreiber,
      Andy Seaborne, Manu Sporny, Thomas Steiner, Ted Thibodeau, Mischa Tuffield,
      William Waites, Jan Wielemaker, David Wood, Zhe Wu, and Antoine Zimmermann.</p>
  </section>

  <section class="informative">
    <h3>Acknowledgments for RDF 1.2</h3>

    <p>In addition to the editors, the following people have contributed to this specification:
      <span id="gh-contributors"></span>
    </p>

    <p data-include="common/participants.html"></p>

    <p class="ednote">Recognize members of the Task Force? Not an easy to find list of contributors.</p>
  </section>
</section>

<section class="appendix informative" id="changes-12">
  <h2>Changes between RDF 1.1 and RDF 1.2</h2>

  <ul>
    <li>Added <a href="#section-classic-full-interop" class="sectionRef"></a>
      for informative mappings between RDF [=Full=] and RDF [=Classic=].</li>
    <li>Added <a href="#section-dataset-quad" class="sectionRef"></a>
      for informative definition of a <a>quad</a>.</li>
   <li>Added <a href="#section-triple-terms-reification" class="sectionRef"></a>
      and definitions for <a>triple term</a> and <a>asserted triple</a>
      and extended the definition of
      <a>RDF triple</a> to permit triple terms as objects.
      Also defines <a>reifier</a> and <a>reifying triple</a>.</li>
    <li>Added the <a>base direction</a> element as part of 
      a <a>literal</a>,
      and a description of its use in <a href="#section-text-direction" class="sectionRef"></a>.</li>
    <li>Improved the use of IRI terminology,
      and added <a href="#iri-abnf" class="sectionRef"></a>.
      This improves the language using <a>relative IRI references</a>
      and clarifies that, in the abstract syntax, IRIs are resolved,
      avoiding the incorrect use of "absolute IRI".</li>
    <li>Changed reference from DOM4, which was not a recommendation at the time, to [[DOM]],
      making the definitions of <a>rdf:HTML</a> and <a>rdf:XMLLiteral</a> datatypes normative.</li>
    <li>Added <a href="#section-additional-datatypes" class="sectionRef"></a>
      and moved the sections about the <a>rdf:HTML</a> and <a>rdf:XMLLiteral</a>
      datatypes to this appendix.</li>
    <li>Added the <a>rdf:JSON</a> datatype, the definition of which is adopted
      from <a data-cite="?JSON-LD11#the-rdf-json-datatype">Section&nbsp;10.2 The `rdf:JSON` Datatype</a>
      in [[?JSON-LD11]].
      Note that the <a href="#JSON-value-space">value space</a> defined here
      updates the <a>value space</a> of the
      <a data-cite="JSON-LD11#the-rdf-json-datatype">`rdf:JSON`</a> datatype defined in [[[JSON-LD11]]] [[JSON-LD11]]</li>
    <li>Clarify Unicode terminology,
      using <a data-cite="I18N-GLOSSARY#dfn-code-point" class="lint-ignore">Unicode code points</a>,
      and restriction to the XML <a data-cite="XML11#charsets">Char</a> production.
      Also removes obsolete recommendations for the use of Normalization Form C in literals.
      Adds a definition of <a>string</a> that can be used in other RDF documents.</li>
    <li>Minor edit
      to improve the example about distinguishing literals, IRIs, and blank nodes
      in <a href="#section-triples" class="sectionRef"></a>.</li>
    <li>Implementations were previously allowed to normalize language tags to lower case,
      which made it ambiguous whether two literals with language tags
      that differed only by case represented the same literal,
      or distinct literals.
      RDF 1.2 requires that language tags be case-insensitively unique 
      but does not specify the common formatting to be used.
      Two literals with the same lexical form and language tags that differ only by case
      are the same literal.
      Implementations can either follow the advice to normalize to lower case,
      use the recommended BCP47 format,
      or do something else, as long it is performed consistently.</li>
    <li>Added explicit definitions of [=blank node equality=], [=RDF term equality=], and [=triple equality=].</li>
    <li>Removed the section on the canonical mapping for the <a>rdf:XMLLiteral</a> datatype.</li>
    <li>Refer to the definition and discussion of 
      <a data-cite="RDF12-SEMANTICS#dfn-recognize">RDF Semantics, "recognizing"</a>
      datatype IRIs, instead of <em>Recognized datatype IRIs</em>.</li>
    <li>The informal terminology "RDF processor" has been removed.</li>
  </ul>

  <p class="note">A detailed overview of the differences between RDF versions&nbsp;1.1
    and 1.2 can be found in [[[RDF12-NEW]]] [[RDF12-NEW]].</p>
</section>

<section id="index"></section>

<section class="appendix" id="issue-summary">
  <!-- A list of issues will magically appear here -->
</section>

</body>
</html>
